<documents>
<document index="1">
<source>namada-src/namada-docs/packages/docs/pages/introduction/install/binaries/overview-of-binaries.mdx</source>
<document_content>
import { Callout } from 'nextra-theme-docs'

# Using the binaries

Once installed, you should have the following binaries:

| Binary | Description |
| --- | --- |
| `namada` | The main binary that can be used to interact with all the components of Namada |
| `namadan` | The ledger node |
| `namadac` | The client |
| `namadaw` | The wallet |
| `namadar` | The ethereum bridge relayer |

The main binary `namada` has sub-commands for all of the other binaries. Therefore, the following commands are equivalent:

| `namada` command | `namada`x equivalent |
| --- | --- |
| `namada client` | `namadac` |
| `namada node` | `namadan` |
| `namada wallet` | `namadaw` |
| `namada relayer` | `namadar` |


To explore the command-line interface, the `--help` argument can be added at any sub-command level to find out any possible sub-commands and/or arguments.


</document_content></document>

<document index="2">
<source>namada-src/namada-docs/packages/docs/pages/operators/ibc.mdx</source>
<document_content>
import { Callout } from 'nextra-theme-docs'
import Expandable from '../../components/Expandable'

# Relaying on Namada

This document describes how to operate a relayer for the Inter-Blockchain Communication (IBC) protocol with Namada. This documentation covers being able to create connections through IBC as well as setting up local chains of Namada for testing purposes.


This document covers essential steps for using IBC with Namada:

1. [Configure Hermes](#configure-hermes)
2. [Install Hermes](#install-hermes)
3. [Setting up the relayer](#setting-up-the-relayer)
4. [Start the relayer](#start-the-relayer)
5. [Set up local Namada chains](#set-up-local-namada-chains-using-the-hermes-script)

The below is intended for those that wish to relay IBC message transfers between two Namada chains. There is of course the capability to do this between any two IBC compatible chains (such as a Cosmos chain).
In this case, it is necessary to have a node running on both the destination and the source chain in order to make any package transfers.
Below, we discuss first how to enable this connection between two pre-existing chains by Hermes, and second, setting up two Namada local chains for this purpose.


## Configure Hermes
Hermes is an IBC relayer to relay IBC packets between chains.
Namada uses a [fork of Hermes supporting Namada chains](https://github.com/heliaxdev/hermes/tree/v1.7.4-namada-beta7).

### Make Hermes config file
One essential piece of the puzzle is to create a `config.toml` file that describes what connections will be set up that the relayer will be responsible for.

```bash copy
export HERMES_CONFIG="<choose path for hermes config>/config.toml"
touch $HERMES_CONFIG
``` 

If you don't specify the file path, `~/.hermes/config.toml` is read as default.

You can find an example of the config file below. Essentially, you change only the chain IDs, the RPC addresses, and the key names in the config file for Namada. If you don't have nodes, please set up nodes manually or through our [scripts](#set-up-local-namada-chains-using-the-hermes-script).

<details>
<summary>Example: config.toml</summary>
```toml copy
[global]
log_level = 'info'

[mode]

[mode.clients]
enabled = true
refresh = true
misbehaviour = true

[mode.connections]
enabled = false

[mode.channels]
enabled = false

[mode.packets]
enabled = true
clear_interval = 10
clear_on_start = false
tx_confirmation = true

[telemetry]
enabled = false
host = '127.0.0.1'
port = 3001

[[chains]]
id = 'namada-test.0a4c6786dbda39f786'  # set your chain ID
type = 'Namada'
rpc_addr = 'http://127.0.0.1:27657'  # set the IP and the port of the chain
grpc_addr = 'http://127.0.0.1:9090'  # not used for now
event_source = { mode = 'push', url = 'ws://127.0.0.1:27657/websocket', batch_delay = '500ms' }  # set the IP and the port of the chain
account_prefix = ''  # not used
key_name = 'relayer'  # The key is an account name you made
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'atest1v4ehgw36x9ry2dphx5mrvdjxgez5gdengeq5gs2pg3znx32yg9p5yv2zg3pnjvf4g9q5x329epndn0' }  # the price isn't used for now, the denom should be a raw token address

[[chains]]
id = 'namada-test.647287156defa8728c'
type = 'Namada'
rpc_addr = 'http://127.0.0.1:28657'
grpc_addr = 'http://127.0.0.1:9090'
event_source = { mode = 'push', url = 'ws://127.0.0.1:28657/websocket', batch_delay = '500ms' }
account_prefix = ''
key_name = 'relayer'
store_prefix = 'ibc'
gas_price = { price = 0.001, denom = 'atest1v4ehgw36xazry3pn89q5xv3ngyungs3hxc65vwp3xez5zdp3xppy2v6yxc65zsfegyc5yd2ptuf9d8' }
```
</details>

The path to the config file, which is saved in the variable `$HERMES_CONFIG` will be useful later.


<Callout type="info" emoji="🧩">
**Interpreting the toml**

Each chain configuration is specified under the `[[chains]]` object.
These are the pieces of this puzzle you want to keep your 👀 on:
 - `chains.id` is the name of the chain
 - `chains.rpc_address` specifies the port that the channel is communicating through, and will be the argument for the `ledger_address` of Namada when interacting with the ledger (will become clearer later)
     - Make sure to change the IP address to the IP address of your local machine that is running this node!
 - `chains.key_name` specifies the key of the signer who signs a transaction from the relayer. The key should be generated before starting the relayer.
 - `chains.event_source` specifies the URL of the chain's websocket. This must be the same as the `rpc_address` for Hermes to work properly.
 - `chains.gas_price.denom` specifies the token that the relayer pays for IBC transactions. `chains.gas_price.price` isn't used for now.

You can see more details of configuration in [the official document](https://hermes.informal.systems/documentation/configuration).
</Callout>

### Export environment variables
The relaying user will need to save certain environment variables. These are:
```bash copy
export CHAIN_A_ID="<replace-with-chain-a-id>"
export CHAIN_B_ID="<replace-with-chain-b-id>"
export HERMES_CONFIG="<replace-with-hermes-config-path>"
```

## Install Hermes
Before conducting any IBC operations, one must download Heliax's fork Hermes binary or build it from source.

### From binaries
One can download the latest binary release from our [releases page](https://github.com/heliaxdev/hermes/releases) by choosing the appropriate architecture.

E.g.
```bash copy
export TAG="v1.7.4-namada-beta7"
export ARCH="x86_64-unknown-linux-gnu" # or "aarch64-apple-darwin"
curl -Lo /tmp/hermes.tar.gz https://github.com/heliaxdev/hermes/releases/download/${TAG}/hermes-${TAG}-${ARCH}.tar.gz
tar -xvzf /tmp/hermes.tar.gz -C /usr/local/bin
```

<Callout type="info">
For some systems, `/usr/local/bin` is a protected directory. In this case, you may need to run the above command with `sudo`.
I.e 
```bash copy
sudo tar -xvzf /tmp/hermes.tar.gz -C /usr/local/bin
```
This is also true for the command `cp ./target/release/hermes /usr/local/bin/` below (see the comment).
</Callout>

### From source
```bash copy
export TAG="v1.7.4-namada-beta7"

git clone https://github.com/heliaxdev/hermes.git
git checkout $TAG
cd hermes
cargo build --release --bin hermes
export HERMES=$(pwd) # if needed
```
Check the binary:
```bash copy
./target/release/hermes --version #or sudo cp ./target/release/hermes /usr/local/bin/
```

<Callout type="info">
It is recommended to now add hermes to `$PATH` such that it is callable without any pre-fixes.
For ubuntu users, this can be achieved by
```bash copy
cp ./target/release/hermes /usr/local/bin/
```
</Callout>

## Setting up the relayer

### Create the relayer account
On each chain, there must be a `relayer` account. The alias should be the same as `chains.key_name` in the config. On a namada chain, this can be done by running
```bash copy
namadaw gen --alias relayer
```

This will generate a key for the relayer account. The key will be stored in the `wallet.toml` that is found in the [base directory](./ledger/base-directory.mdx) of the node, inside the `chain-id` folder. For example, if the `chain-id` is `namada-test.0a4c6786dbda39f786`, the `wallet.toml` will be found in `$HOME/.local/share/namada/namada-test.0a4c6786dbda39f786/wallet.toml` (on a ubuntu machine where `base-dir` has not been set up properly).

The relayer account should have some balance to pay the fee of transactions. Before creating an IBC channel or relaying an IBC packet, you need to transfer the fee token to the relayer account.

### Add the relayer key to Hermes
To sign each transaction, the relayer's key should be added to Hermes with `keys add` command in advance. It requires the `wallet.toml` which should have the key of `chains.key_name`. Once the key has been added, Hermes doesn't need the wallet anymore.
```bash copy
hermes --config $HERMES_CONFIG keys add --chain $CHAIN_ID --key-file $WALLET_PATH
```

Hermes will store the key in `~/.hermes/keys/${CHAIN_ID}` as default. You can specify the directory by setting `chains.key_store_folder` in the config file.

<Callout type="info">
If you want to use an encrypted key with a password, you have to set an environment variable `NAMADA_WALLET_PASSWORD_FILE` for the password file or `NAMADA_WALLET_PASSWORD` to avoid entering the password for each transaction submission.
</Callout>

It is now possible to set up the client.

### Create IBC channel
The "create channel" command (below) creates not only the IBC channel but also the necessary IBC client connection.

```bash copy
hermes --config $HERMES_CONFIG \
  create channel \
  --a-chain $CHAIN_A_ID \
  --b-chain $CHAIN_B_ID \
  --a-port transfer \
  --b-port transfer \
  --new-client-connection --yes
```

<Callout type="info">
Note that the above `CHAIN_IDs` will depend on your own setup, so do check this for yourself!
</Callout>

When the creation has been completed, you can see the channel IDs. For example, the following text shows that a channel with ID `7` has been created on Chain A `namada-test.0a4c6786dbda39f786`, and a channel with ID `12` has been created on Chain B `namada-test.647287156defa8728c`. You will need the channel IDs for a transfer over IBC. It means that you have to specify `channel-7` as a channel ID (The prefix `channel-` is always required) for a transfer from Chain A to Chain B. Also, you have to specify `channel-12` as a channel ID for a transfer from Chain B to Chain A.

<Expandable>
```
SUCCESS Channel {
    ordering: Unordered,
    a_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "namada-test.0a4c6786dbda39f786",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-0",
        ),
        connection_id: ConnectionId(
            "connection-3",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-7",
            ),
        ),
        version: None,
    },
    b_side: ChannelSide {
        chain: BaseChainHandle {
            chain_id: ChainId {
                id: "namada-test.647287156defa8728c",
                version: 0,
            },
            runtime_sender: Sender { .. },
        },
        client_id: ClientId(
            "07-tendermint-1",
        ),
        connection_id: ConnectionId(
            "connection-2",
        ),
        port_id: PortId(
            "transfer",
        ),
        channel_id: Some(
            ChannelId(
                "channel-12",
            ),
        ),
        version: None,
    },
    connection_delay: 0ns,
}
```
</Expandable>

## Start the relayer
Once you run Hermes, it monitors chains via the nodes and relays packets according to monitored events.
```bash copy
hermes --config $HERMES_CONFIG start
```

You can see more details of Hermes at [the official document](https://hermes.informal.systems/).

After the sync, you can create the channel and start Hermes as explained [above](#create-ibc-channel).
```bash copy
# create a channel
hermes --config $HERMES_CONFIG \
  create channel \
  --a-chain $CHAIN_A_ID \
  --b-chain $CHAIN_B_ID \
  --a-port transfer \
  --b-port transfer \
  --new-client-connection --yes
```

### Transferring assets over IBC
It is now possible to [transfer assets between the two chains.](../users/ibc.mdx)

## Set up local Namada chains using the Hermes script
The script `setup-namada` will set up two chains with one validator node, copy necessary files for Hermes, and make an account for Hermes on each ledger. Also, it will make a Hermes' config file `config_for_namada.toml` in the `hermes` directory.

First, you will need to export some environment variables:

```bash copy
export NAMADA_DIR="<path-to-namada-source-directory>"
export TAG="v1.7.4-namada-beta7"
```

```bash copy
git clone https://github.com/heliaxdev/hermes.git
git checkout $TAG # The branch is the same as our Hermes
cd hermes
./scripts/setup-namada $NAMADA_DIR
```

In this case, the user doesn't have to wait for sync. If the relayer account on each instance has enough balance, the user can create a channel and start Hermes immediately as explained [above](#create-ibc-channel). The user finds these chain IDs of the chains in the config file `config_for_namada.toml`. One can run `grep "id" ${HERMES_CONFIG}`.
```bash copy
# create a channel
hermes --config $HERMES_CONFIG \
  create channel \
  --a-chain $CHAIN_A_ID \
  --b-chain $CHAIN_B_ID \
  --a-port transfer \
  --b-port transfer \
  --new-client-connection --yes

# Run Hermes
hermes --config $HERMES_CONFIG start
```

Each node data and configuration files are in `hermes/data/namada-*/.namada`.

In order to close any ledgers setup by the script, one can run
```bash copy
killall namadan
```

</document_content></document>

<document index="3">
<source>namada-src/namada/documentation/dev/src/explore/design/ledger/ibc.md</source>
<document_content>
# IBC integration

[IBC](https://arxiv.org/pdf/2006.15918.pdf) allows a ledger to track another ledger's consensus state using a light client. IBC is a protocol to agree the consensus state and to send/receive packets between ledgers.

We have mainly two components for IBC integration, IBC handler and IBC validity predicate. IBC handler is a set of functions to handle IBC-related data. A transaction calls these functions for IBC operations. IBC validity predicate is a native validity predicate to validate the transaction which mutates IBC-related data.

## Storage key of IBC-related data
Its storage key should be prefixed with [`InternalAddress::Ibc`](https://github.com/anoma/namada/blob/e3c2bd0b463b35d66fcc6d2643fd0e6509e03d99/core/src/types/address.rs#L446) to differ them from other storage operations. A path after the prefix specifies an IBC-related data. The paths are defined by [ICS 24](https://github.com/cosmos/ibc/blob/master/spec/core/ics-024-host-requirements/README.md#path-space). The utility functions for the keys are defined [here](https://github.com/anoma/namada/blob/e3c2bd0b463b35d66fcc6d2643fd0e6509e03d99/core/src/ledger/ibc/storage.rs). For example, a client state of a counterparty ledger will be stored with a storage key `#IBC_encoded_addr/clients/{client_id}/clientState`. The IBC transaction and IBC validity predicate can use the storage keys to read/write IBC-related data according to IBC protocol.

## IBC transaction
A requester (IBC relayer or user) who wants to execute IBC operations on a ledger should make a transaction and an IBC message as transaction data, and submit a transaction with the transaction data. We provide [`tx_ibc.wasm`](https://github.com/anoma/namada/blob/e3c2bd0b463b35d66fcc6d2643fd0e6509e03d99/wasm/wasm_source/src/tx_ibc.rs) for IBC transaction.

The transaction can mutate the ledger state by writing not only data specified in the transaction but also IBC-related data on the storage sub-space. It depends on the given IBC message. The [`dispatch`](https://github.com/anoma/namada/blob/e3c2bd0b463b35d66fcc6d2643fd0e6509e03d99/core/src/ledger/ibc/actions.rs#L180) function will check the message and call the corresponding IBC operations. Also, it emits an IBC event at the end of the transaction.

### Handle IBC operations
IBC transaction mutates the ledger state. We provides IBC operations, e.g. [`create_client`](https://github.com/anoma/namada/blob/e3c2bd0b463b35d66fcc6d2643fd0e6509e03d99/core/src/ledger/ibc/actions.rs#L233). Basically, they read IBC-related data, check and update them according to IBC protocol. For example, when it receives a message `MsgCreateAnyClient` to create a new client for the counterparty chain, the transaction increments the client counter, makes a new client ID and inserts the client type, the client state and the client consensus state, then emits an event with the client ID. The transaction accesses the storage through the host environment functions.

### Emit IBC event
The ledger should set an IBC event to `events` in the ABCI response to allow relayers to get the events.

[`TxResult`](https://github.com/anoma/namada/blob/e3c2bd0b463b35d66fcc6d2643fd0e6509e03d99/core/src/types/transaction/mod.rs#L45) can have `IbcEvent`. [`IbcEvent`](https://github.com/anoma/namada/blob/e3c2bd0b463b35d66fcc6d2643fd0e6509e03d99/core/src/types/ibc.rs#L11) should have the IBC event type and necessary data according to the IBC operation. A transaction sets `IbcEvent` on the write log as non-committed data with the host environment function [`tx_emit_ibc_event`](https://github.com/anoma/namada/blob/e3c2bd0b463b35d66fcc6d2643fd0e6509e03d99/shared/src/vm/host_env.rs#L986). When the block is finalized, [the event is given to the ABCI response](https://github.com/anoma/namada/blob/e3c2bd0b463b35d66fcc6d2643fd0e6509e03d99/apps/src/lib/node/ledger/shell/finalize_block.rs#L194).

IBC relayer can get these events by subscribing to the ledger with Tendermint RPC or getting the response after the relayer submits a transaction. It is parsed in the relayer by [`from_tx_response_event()`](https://github.com/informalsystems/ibc-rs/blob/26087d575c620d1ec57b3343d1aaf5afd1db72d5/modules/src/events.rs#L167-L181).

## IBC validity predicate
IBC validity predicate is invoked after the transaction execution to validate the IBC operations. The trigger invoking IBC validity predicate is changing IBC-related data whose key is prefixed with `#IBC-encoded-addr`.

IBC validity predicate validates that the state changes by the IBC transaction are valid by checking the ledger state including prior and posterior. If the validation succeeds, the state changes are committed and the event is emitted. If the validation fails, the IBC-related mustations are dropped and the event isn't emitted. For the performance, IBC validity predicate is a [native validity predicate](vp.md#native-vps) that are built into the ledger.

IBC validity predicate has to execute the following validations for state changes of IBC-related data. `validate_tx` calls the corresponding validation functions according to the prefix of each storage key.

```rust
/* shared/src/ledger/ibc/vp/mod.rs */

/// IBC VP
pub struct Ibc<'a, DB, H, CA>
where
    DB: ledger_storage::DB + for<'iter> ledger_storage::DBIter<'iter>,
    H: StorageHasher,
    CA: 'static + WasmCacheAccess,
{
    /// Context to interact with the host structures.
    pub ctx: Ctx<'a, DB, H, CA>,
}

impl NativeVp for Ibc {

    fn validate_tx(
        &self,
        tx_data: &[u8],
        keys_changed: &BTreeSet<Key>,
        _verifiers: &BTreeSet<Address>,
    ) -> Result<bool> {
        for key in keys_changed {
            // Check the prefix of the storage key
            if let Some(ibc_prefix) = ibc_prefix(key) {
                match ibc_prefix {
                    IbcPrefix::Client => {
                        if is_client_counter_key(key) {
                            // Check if the counter is incremented
                        } else {
                            let client_id = get_client_id(key);
                            // client validation
                            self.validate_client(&client_id, tx_data)?
                        }
                    }
                    IbcPrefix::Connection => {
                        self.validate_connection(key, tx_data)?
                    }
                    IbcPrefix::Channel => {
                        self.validate_channel(key, tx_data)?
                    }
                    IbcPrefix::Port => self.validate_port(key)?,
                    IbcPrefix::Capability => self.validate_capability(key)?,
                    IbcPrefix::SeqSend => {
                        self.validate_sequence_send(key, tx_data)?
                    }
                    IbcPrefix::SeqRecv => {
                        self.validate_sequence_recv(key, tx_data)?
                    }
                    IbcPrefix::SeqAck => {
                        self.validate_sequence_ack(key, tx_data)?
                    }
                    IbcPrefix::Commitment => {
                        self.validate_commitment(key, tx_data)?
                    }
                    IbcPrefix::Receipt => {
                        self.validate_receipt(key, tx_data)?
                    }
                    IbcPrefix::Ack => self.validate_ack(key)?,
                    IbcPrefix::Event => {}
                    IbcPrefix::Unknown => {
                        return Err(Error::KeyError(format!(
                            "Invalid IBC-related key: {}",
                            key
                        )));
                    }
                }
            }
        }
        Ok(true)
    }
```

### Client validation
The IBC client is validated by checking the state change for updating or upgrading. `ibc-rs` provides the check functions for the updating and upgrading.

```rust
impl<'a, DB, H, CA> Ibc<'a, DB, H, CA>
where
    DB: 'static + storage::DB + for<'iter> storage::DBIter<'iter>,
    H: 'static + StorageHasher,
    CA: 'static + WasmCacheAccess,
{
    pub(super) fn validate_client(
        &self,
        client_id: &ClientId,
        tx_data: &[u8],
    ) -> Result<()> {
        // Check the client state change
        match self.get_client_state_change(client_id)? {
            StateChange::Created => {
                // "CreateClient"
                // Confirm that the corresponding consensus state exists
            }
            StateChange::Updated => {
                // check the message
                let ibc_msg = IbcMessage::decode(tx_data)?;
                match ibc_msg.0 {
                    Ics26Envelope::Ics2Msg(ClientMsg::UpdateClient(msg)) => {
                        // Check the header, the updated client state and consensus state
                        //   - Refer to `ibc-rs::ics02_client::client_def::check_header_and_update_state()`
                    }
                    Ics26Envelope::Ics2Msg(ClientMsg::UpgradeClient(msg)) => {
                        // Check the upgraded client state and consensus state
                        //   - Refer to `ibc-rs::ics02_client::client_def::verify_upgrade_and_update_state()`
                    }
                    _ => Err(Error::InvalidStateChange(format!(
                        "The state change of the client is invalid: ID {}",
                        client_id
                    ))),
                }

            }
            _ => Err(Error::InvalidStateChange(format!(
                "The state change of the client is invalid: ID {}",
                client_id
            ))),
        }
    }
}
```

### Connection validation
The IBC connection is validated by checking the state change for creating or updating in connection handshake. Some validations requires proof verification to verify the counterparty state. `ibc-rs` provides the proof verification function for the counterparty connection end.

```rust
impl<'a, DB, H, CA> Ibc<'a, DB, H, CA>
where
    DB: 'static + storage::DB + for<'iter> storage::DBIter<'iter>,
    H: 'static + StorageHasher,
    CA: 'static + WasmCacheAccess,
{
    pub(super) fn validate_connection(
        &self,
        key: &Key,
        tx_data: &[u8],
    ) -> Result<()> {
        if is_connection_counter_key(key) {
            // Check if the counter is incremented
            return Ok(());
        }

        // Check if the connection end exists
        let conn_id = connection_id(key)?;
        let conn = self.connection_end(&conn_id).map_err(|_| {
            Error::InvalidConnection(format!(
                "The connection doesn't exist: ID {}",
                conn_id
            ))
        })?;

        // Check the state change
        match self.get_connection_state_change(&conn_id)? {
            StateChange::Created => {
                match conn.state() {
                    State::Init => {
                        // "ConnectionOpenInit"
                        // Confirm that the corresponding client exists
                    }
                    State::TryOpen => {
                        // "ConnectionOpenTry"
                        // Confirm that the version is compatible

                        // Verify the proofs to check if the counterparty connection end exists as expected
                        //   - Use `ibc-rs::ics03_connection::handler::verify::verify_proofs()`
                    }
                }
            }
            StateChange::Updated => {
                if conn.state() != State::Open {
                    return Err(Error::InvalidConnection(format!(
                        "The state of the connection is invalid: ID {}",
                        conn_id
                    )));
                }
                // Check the previous state of the connection end
                let prev_conn = self.connection_end_pre(conn_id)?;
                match prev_conn.state() {
                    State::Init => {
                        // "ConnectionOpenAck"
                        // Verify the proofs to check if the counterparty connection end exists as expected
                        //   - Use `ibc-rs::ics03_connection::handler::verify::verify_proofs()`
                    }
                    State::TryOpen => {
                        // "ConnectionOpenConfirm"
                        // Verify the proofs to check if the counterparty connection end exists as expected
                        //   - Use `ibc-rs::ics03_connection::handler::verify::verify_proofs()`
                    }
                }
            }
            _ => Err(Error::InvalidStateChange(format!(
                "The state change of the connection is invalid: ID {}",
                conn_id
            ))),
        }
    }
}
```

### Port/Channel validation
The IBC port and channel end are validated by checking the state change for creating or updating in channel handshake as the connection validation. The validation function also checks the state change when the channel end is closed unlike a connection end. When packet timeout, the validation has to confirm that the commitment has been deleted. This deletion will trigger the packet validation for the timed-out packet.

```rust
impl<'a, DB, H, CA> Ibc<'a, DB, H, CA>
where
    DB: 'static + ledger_storage::DB + for<'iter> ledger_storage::DBIter<'iter>,
    H: 'static + StorageHasher,
    CA: 'static + WasmCacheAccess,
{
    pub(super) fn validate_port(&self, key: &Key) -> Result<()> {
        let port_id = port_id(key)?;
        match self.get_port_state_change(&port_id)? {
            StateChange::Created => {
                // Confirm that the port is owend
            }
            StateChange::Updated => {
                // Check the port is bound to another channel or released properly
            }
            _ => Err(Error::InvalidPort(format!(
                "The state change of the port is invalid: Port {}",
                port_id
            ))),
        }
    }
}
```

```rust
impl<'a, DB, H, CA> Ibc<'a, DB, H, CA>
where
    DB: 'static + ledger_storage::DB + for<'iter> ledger_storage::DBIter<'iter>,
    H: 'static + StorageHasher,
    CA: 'static + WasmCacheAccess,
{
    pub(super) fn validate_channel(
        &self,
        key: &Key,
        tx_data: &[u8],
    ) -> Result<()> {
        if is_channel_counter_key(key) {
            // Check if the counter is incremented
            return Ok(());
        }

        // Confirm that the port is owend
        // Confirm that the version is compatible

        // Check the channel state change
        match self.get_channel_state_change(&port_channel_id)? {
            StateChange::Created => match channel.state() {
                State::Init => {
                    // "ChannelOpenInit"
                }
                State::TryOpen => {
                    // "ChannelOpenTry"
                    // Verify the proof to check if the counterparty channel end exists as expected
                    //   - Use `ibc-rs::ics04_connection::handler::verify::verify_channel_proofs()`
                }
                _ => Err(Error::InvalidChannel(format!(
                    "The channel state is invalid: Port/Channel {}, State {}",
                    port_channel_id,
                    channel.state()
                ))),
            },
            StateChange::Updated => {
                let prev_channel = self.channel_end_pre(port_channel_id)?;
                match channel.state() {
                    State::Open => match prev_channel.state() {
                        State::Init => {
                            // "ChannelOpenAck"
                            // Verify the proof to check if the counterparty channel end exists as expected
                            //   - Use `ibc-rs::ics04_connection::handler::verify::verify_channel_proofs()`
                        }
                        State::TryOpen => {
                            // "ChannelOpenConfirm"
                            // Verify the proof to check if the counterparty channel end exists as expected
                            //   - Use `ibc-rs::ics04_connection::handler::verify::verify_channel_proofs()`
                        }
                    }
                    State::Closed => {
                        // Confirm that the previous state is State::Open

                        // Check the message
                        let ibc_msg = IbcMessage::decode(tx_data)?;
                        match ibc_msg.0 {
                            Ics26Envelope::Ics4PacketMsg(PacketMsg::ToPacket(msg)) => {
                                // "TimeoutPacket"
                                // Confirm that the commitment has been deleted
                                //    - The state change of the commitment triggers the packet validation
                            }
                            Ics26Envelope::Ics4PacketMsg(PacketMsg::ToClosePacket(
                                msg,
                            )) => {
                                // "TimeoutOnClosePacket"
                                // Confirm that the commitment has been deleted
                                //    - The state change of the commitment triggers the packet validation
                            }
                            Ics26Envelope::Ics4ChannelMsg(
                                ChannelMsg::ChannelCloseInit(msg),
                            ) => {
                                // "ChannelCloseInit"
                            }
                            Ics26Envelope::Ics4ChannelMsg(
                                ChannelMsg::ChannelCloseConfirm(msg),
                            ) => {
                                // "ChannelCloseConfirm"
                                // Verify the proof to check if the counterparty channel end exists as expected
                                //   - Use `ibc-rs::ics04_connection::handler::verify::verify_channel_proofs()`
                            }
                            _ => Err(Error::InvalidMessage(format!(
                                "The state change of the channel is invalid for the message: \
                                 Port/Channel {}",
                                port_channel_id,
                            ))),
                        }
                    }
                }
            }
            _ => Err(Error::InvalidStateChange(format!(
                "The state change of the channel: Port/Channel {}",
                port_channel_id
            ))),
        }
    }
}
```

### Sequence validation
When the packet sending, receiving, or acknowledgement, the sequence counter is incremented. The sequence validation checks these sequences and the existence of the commitment, the receipt, or acknowledgement. The contents of them are validated in the packet validation functions.

```rust
impl<'a, DB, H, CA> Ibc<'a, DB, H, CA>
where
    DB: 'static + ledger_storage::DB + for<'iter> ledger_storage::DBIter<'iter>,
    H: 'static + StorageHasher,
    CA: 'static + WasmCacheAccess,
{
    pub(super) fn validate_sequence_send(
        &self,
        key: &Key,
        tx_data: &[u8],
    ) -> Result<()> {
        // Confirm that the sequence is incremented
        // Confirm that the commitment exists
    }

    pub(super) fn validate_sequence_recv(
        &self,
        key: &Key,
        tx_data: &[u8],
    ) -> Result<()> {
        // Confirm that the sequence is incremented
        // Confirm that the receipt and the acknowledgement exist
    }

    pub(super) fn validate_sequence_ack(
        &self,
        key: &Key,
        tx_data: &[u8],
    ) -> Result<()> {
        // Confirm that the sequence is incremented
        // Confirm that the commitment doesn't exist
    }
}
```

### Packet validation
The validation functions should check commitment, receipt, and acknowledgement which are stored or deleted when packet sending, receiving or acknowledgement. And, when the commitment has been deleted, the packet timeout should be checked.

```rust
impl<'a, DB, H, CA> Ibc<'a, DB, H, CA>
where
    DB: 'static + storage::DB + for<'iter> storage::DBIter<'iter>,
    H: 'static + StorageHasher,
    CA: 'static + WasmCacheAccess,
{
    pub(super) fn validate_commitment(
        &self,
        key: &Key,
        tx_data: &[u8],
    ) -> Result<()> {
        // check if the commitment is stored or deleted
        match self
            .get_state_change(key)
            .map_err(|e| Error::InvalidStateChange(e.to_string()))?
        {
            StateChange::Created => {
                // "SendPacket"
                // Confirm that the channel is open
                // Validate the sent packet
                // Confirm that the expected commitment exists
            }
            StateChange::Deleted => {
                let ibc_msg = IbcMessage::decode(tx_data)?;
                match channel.state() {
                    State::Open => {
                        match &ibc_msg.0 {
                            Ics26Envelope::Ics4PacketMsg(
                                PacketMsg::AckPacket(msg),
                            ) => {
                                // "PacketAcknowledgement"
                                // Verify the proof to check if the expected ack exists on the counterparty
                            }
                            Ics26Envelope::Ics4PacketMsg(
                                PacketMsg::ToPacket(_),
                            )
                            | Ics26Envelope::Ics4PacketMsg(
                                PacketMsg::ToClosePacket(_),
                            ) => {
                                // "PacketTimeout"
                                // Confirm that the deleted commitment was for the channel and the counterparty
                                if !is_timed_out(packet) {
                                    // "PacketTimedoutOnClose"
                                    // Verify the proof to check if the counterparty channel is closed
                                }
                            }
                            _ => Err(Error::InvalidChannel(format!(
                                "The channel state is invalid: Port {}, \
                                 Channel {}",
                                commitment_key.0, commitment_key.1
                            ))),
                        }
                    }
                    State::Closed => {
                        // "PacketTimeout"
                        // Confirm that the deleted commitment was for the channel and the counterparty
                        // Confirm that the packet timed out
                    }
                    _ => Err(Error::InvalidChannel(format!(
                        "The channel state is invalid: Port {}, Channel {}",
                        commitment_key.0, commitment_key.1
                    ))),
                }
            }
            _ => Err(Error::InvalidStateChange(format!(
                "The state change of the commitment is invalid: Key {}",
                key
            ))),
        }

            }
        }
    }

    pub(super) fn validate_receipt(
        &self,
        key: &Key,
        tx_data: &[u8],
    ) -> Result<()> {
        // Check the state change of the receipt
        match self
            .get_state_change(key)
            .map_err(|e| Error::InvalidStateChange(e.to_string()))?
        {
            StateChange::Created => {
                OK(())
            }
            _ => Err(Error::InvalidStateChange(
                "The state change of the receipt is invalid".to_owned(),
            )),
        }
    }

    pub(super) fn validate_ack(&self, key: &Key) -> Result<()> {
        match self
            .get_state_change(key)
            .map_err(|e| Error::InvalidStateChange(e.to_string()))?
        {
            StateChange::Created => {
                // Confirm that the receipt exists
            }
            _ => Err(Error::InvalidStateChange(
                "The state change of the acknowledgment is invalid".to_owned(),
            )),
        }
    }
}
```

### Proof
A query for a proven IBC-related data returns the value and the proof. The proof is used to verify if the key-value pair exists or doesn't exist on the counterpart ledger in IBC validity predicate (ICS 23).

The query response has the proof as [`tendermint::merkle::proof::Proof`](https://github.com/informalsystems/tendermint-rs/blob/dd371372da58921efe1b48a4dd24a2597225df11/tendermint/src/merkle/proof.rs#L15), which consists of a vector of [`tendermint::merkle::proof::ProofOp`](https://github.com/informalsystems/tendermint-rs/blob/dd371372da58921efe1b48a4dd24a2597225df11/tendermint/src/merkle/proof.rs#L25). `ProofOp` should have `data`, which is encoded to `Vec<u8>` from [`ibc_proto::ics23::CommitmentProof`](https://github.com/informalsystems/ibc-rs/blob/66049e29a3f5a0c9258d228b9a6c21704e7e2fa4/proto/src/prost/ics23.rs#L49). The relayer getting the proof converts the proof from `tendermint::merkle::proof::Proof` to `ibc::ics23_commitment::commitment::CommitmentProofBytes` by [`convert_tm_to_ics_merkle_proof()`](https://github.com/informalsystems/ibc-rs/blob/66049e29a3f5a0c9258d228b9a6c21704e7e2fa4/modules/src/ics23_commitment/merkle.rs#L84) and sets it to the request data of the following IBC operation.

## Relayer (ICS 18)
IBC relayer monitors the ledger, gets the status, state and proofs on the ledger, and requests transactions to the ledger via Tendermint RPC according to IBC protocol. For relayers, the ledger has to make a packet, emits an IBC event and stores proofs if needed. And, a relayer has to support Namada ledger to query and validate the ledger state. It means that `ChainEndpoint` in IBC Relayer of [ibc-rs](https://github.com/informalsystems/ibc-rs) should be implemented for Anoma like [that of CosmosSDK](https://github.com/informalsystems/ibc-rs/blob/66049e29a3f5a0c9258d228b9a6c21704e7e2fa4/relayer/src/chain/cosmos.rs). As those of Cosmos, these queries can request ABCI queries to Namada.

```rust
impl ChainEndpoint for Namada {
    ...
}
```

## Token Transfer (ICS 20)
### IBC Token VP
IBC token VP checks a transfer of a sent/received/refunded token over IBC. These transfers change the state of accounts sub-prefixed with [`IbcToken` including a hash or the owner address is `IbcEscrow`, `IbcBurn`, `IbcMint`](https://github.com/anoma/namada/blob/e3c2bd0b463b35d66fcc6d2643fd0e6509e03d99/core/src/types/address.rs#L446), i.e. this VP is triggered by the state change of these accounts.

The existing token's VP `vp_token` checks if the total of the changes in the transaction should be zero. IBC-related accounts should be included as general accounts.
IBC token VP as a native VP should check if the escrow/unescrow/burn/mint has been done properly in the transaction. When an IBC transaction has `MsgTransfer`, the VP should check if the amount of the specified token by the message has been escrowed or burned. When an IBC transaction has `MsgRecvPacket` with `FungibleTokenPacketData`, the VP should check if the amount of the specified token by the data has been unescrowed or minted. For example, if a transaction tries to unescrow an amount and to send it to a different account from the specified account, the VP should refuse it, even if the transaction satisfies IBC protocol.

### Send a token
In a transaction with `MsgTransfer` (defined in ibc-rs) including `FungibleTokenPacketData` as transaction data, the specified token is sent according to ICS20 and a packet is sent.
The transaction updates the sender's balance by escrowing or burning the amount of the token. The account, the sent token(denomination), and the amount are specified by `MsgTransfer`. [The denomination field would indicate that this chain is the source zone or the sink zone](https://github.com/cosmos/ibc/blob/master/spec/app/ics-020-fungible-token-transfer/README.md#technical-specification).

#### Sender
Basically, the sender key is `{token_addr}/balance/{sender_addr}`. `{token_addr}` and `{sender_addr}` is specified by `FungibleTokenPacketData`. When the denomination `{denom}` in `FungibleTokenPacketData` specifies the source chain, the transfer operation is executed from the origin-specific account `{token_addr}/ibc/{ibc_token_hash}/balance/{sender_addr}` (Ref. [Receiver](#Receiver)). We can set `{token_addr}`, `{port_id}/{channel_id}/../{token_addr}`, or `ibc/{ibc_token_hash}/{token_addr}` to the denomination. When `ibc/{ibc_token_hash}/` is prefixed, the transfer looks up the prefixed denomination `{port_id}/{channel_id}/{denom}` by the `{ibc_token_hash}`. `{denom}` might have more prefixes to specify the source chains, e.g. `{port_id_b}/{channel_id_b}/{port_id_a}/{channel_id_a}/{token_addr}`. According to the prefixed port ID and channel ID, the transfer operation escrows or burns the amount of the token (ICS20).

#### Escrow
When this chain is the source zone, i.e. the denomination does NOT start with the port ID and the channel ID of this chain, the amount of the specified token is sent from the sender's account key to the escrow key `{token_addr}/ibc/{port_id}/{channel_id}/balance/IbcEscrow`. The escrow address should be associated with IBC port ID and channel ID to unescrow it later. The escrow address is one of internal addresses, `InternalAddress::IbcEscrow`. It is not allowed to transfer from the escrow account without IBC token transfer operation. IBC token VP should check the transfer from the escrow accounts.

#### Burn
When the destination chain was the source, i.e. the denomination starts with the port ID and the channel ID of this chain, the amount of the specified token is sent from the sender's account to a key `{token_addr}/ibc/{port_id}/{channel_id}/balance/IbcBurn`. `IbcBurn` is one of internal addresses, `InternalAddress::IbcBurn`. The value of the key should NOT written to the block when the block is committed, i.e. reading the previous value of the key in a VP results in always `None` and the balance is zero by default. We can use `tx_write_temp` in the transaction for these writes.

### Receive a token
In a transaction with `MsgRecvPacket` (defined in ibc-rs) including `FungibleTokenTransferData` as transaction data, the specified token is received according to ICS20.
The transaction updates the receiver's balance by unescrowing or minting the amount of the token. The account(receiver), the received token(denomination), and the amount are specified by `FungibleTokenPacketData` in the received packet.

#### Receiver
The receiver's account key should be origin-specific because the token should be returned to the source chain if needed. The key is `{token_addr}/ibc/{ibc_token_hash}/balance/{receiver_addr}`. `{ibc_token_hash}` is calculated from the denomination prefixed with this chain's port ID and chain ID, and the token address. And, the original denomination should be persistent with the storage key `#IBC_encoded_addr/denom/{ibc_token_hash}` for looking it up when sending the received token.

#### Unescrow
When this chain was the source zone, i.e. the denomination starts with this chain's port ID and channel ID, the amount of the token is sent from its escrow key `{token_addr}/ibc/{port_id}/{channel_id}/balance/IbcEscrow`.

#### Mint
When this chain is not the source zone, i.e. the denomination does NOT start with this chain's port ID and channel ID, the amount of the token is minted from the mint account `{token_addr}/ibc/{port_id}/{channel_id}/balance/IbcMint`. The `IbcMint` is one of internal addresses, `InternalAddress::IbcMint`. The account is NOT updated when the block is committed same as `IbcBurn`, i.e. reading the previous value of the mint account in a VP results in always the maximum amount.

### Refund tokens
When a packet has timed out or a failure acknowledgement is given, the escrowed or burned amount of the token should be refunded by unescrowing or minting the amount of the token on the chain which has sent the token. i.e. the IBC transaction should transfer the amount of the token from `{token_addr}/ibc/{port_id}/{channel_id}/balance/IbcEscrow` or `{token_addr}/ibc/{port_id}/{channel_id}/balance/IbcMint` to the sender account.

![transfer](./ibc/transfer.svg  "transfer")

</document_content></document>

<document index="4">
<source>namada-src/namada-docs/packages/docs/pages/integrating-with-namada/light-sdk/usage/transactions.mdx</source>
<document_content>
## Transaction
The transaction module exposes various modules (objects) to construct transactions. Each object implements the `::new()` method to create a new instance of the object.

```rust
pub mod account; // contains functions to create transactions for account module
pub mod bridge; // contains functions to create transactions for bridge module
pub mod governance; // contains functions to create transactions for governance module
pub mod ibc; // contains functions to create transactions for ibc module
pub mod pgf; // contains functions to create transactions for pgf module
pub mod pos; // contains functions to create transactions for pos module
pub mod transfer; // contains functions to create transactions for transfer module
```

### Methods associated with every struct

Each struct in the transaction module implements the following methods:

```rust
/// Build a raw transaction from the given parameters
pub fn new(...) -> Self {...}
/// Get the bytes to sign for the given transaction
pub fn get_sign_bytes(&self) -> Vec<Hash> {...}
/// Attach a signature to the given transaction
pub fn attach_signatures(self, signer: common::PublicKey, signature: common::Signature) -> Self {...}
/// Attach a fee to the given transaction
pub fn attach_fee(self, fee: DenominatedAmount, token: Address, fee_payer: common::PublicKey, epoch: Epoch, gas_limit: GasLimit) -> Self {...}
/// Get the bytes of the fee data to sign
pub fn get_fee_sig_bytes(&self) -> Hash {...}
/// Attach a fee signature to the given transaction
pub fn attach_fee_signature(self, signer: common::PublicKey, signature: common::Signature) -> Self {...}
/// Generates the protobuf encoding of this transaction
pub fn to_bytes(&self) -> Vec<u8> {...}
/// Gets the inner transaction without the domain wrapper
pub fn payload(self) -> Tx {...}
/// Validate this wrapper transaction
pub fn validate_tx(&self) -> Result<Option<&Signature>, TxError> {...}
```

Using these modules is given in more detail under the [examples section](../examples.mdx). Below we describe the instantiating of each struct associated with the respective module.

### Account

```rust
use namada_sdk::key::common;
use namada_sdk::hash::Hash;
use super::GlobalArgs;
pub struct InitAccount(Tx);
impl InitAccount {
    pub fn new(
            public_keys: Vec<common::PublicKey>,
            vp_code_hash: Hash,
            threshold: u8,
            args: GlobalArgs,
        ) -> Self {...}
}
```

A public key can be constructed from a string using the `::from_str()` method. The `vp_code_hash` is a hash that is found under the `wasm` folder.

### Bridge

```rust
pub use namada_sdk::eth_bridge_pool::{GasFee, TransferToEthereum};
pub struct BridgeTransfer(Tx);
impl BridgeTransfer {
    pub fn new(
        transfer: TransferToEthereum,
        gas_fee: GasFee,
        args: GlobalArgs,
    ) -> Self {...}
}
```

### Governance

```rust
pub struct InitProposal(Tx);

impl InitProposal {
    /// Build a raw InitProposal transaction from the given parameters
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        id: u64,
        content: Hash,
        author: Address,
        r#type: ProposalType,
        voting_start_epoch: Epoch,
        voting_end_epoch: Epoch,
        grace_epoch: Epoch,
        args: GlobalArgs,
    ) -> Self {...}
}
pub struct VoteProposal(Tx);

impl VoteProposal {
    /// Build a raw VoteProposal transaction from the given parameters
    pub fn new(
        id: u64,
        vote: ProposalVote,
        voter: Address,
        delegations: Vec<Address>,
        args: GlobalArgs,
    ) -> Self {...}
}
```

### IBC

```rust
pub struct IbcTransfer(Tx);

impl IbcTransfer {
    /// Build a raw IbcTransfer transaction from the given parameters
    pub fn new(
        packet_data: MsgTransfer,
        GlobalArgs {
            expiration,
            code_hash,
            chain_id,
        }: GlobalArgs,
    ) -> Self {...}
}
```

### PGF

```rust
pub struct ResignSteward(Tx);

impl ResignSteward {
    /// Build a raw ResignSteward transaction from the given parameters
    pub fn new(steward: Address, args: GlobalArgs) -> Self {...}
}
pub struct UpdateStewardCommission(Tx);

impl UpdateStewardCommission {
    /// Build a raw UpdateStewardCommission transaction from the given
    /// parameters
    pub fn new(
        steward: Address,
        commission: HashMap<Address, Dec>,
        args: GlobalArgs,
    ) -> Self {...}
}
```

### POS

```rust
pub struct Bond(Tx);
impl Bond {
    /// Build a raw Bond transaction from the given parameters
    pub fn new(
        validator: Address,
        amount: token::Amount,
        source: Option<Address>,
        args: GlobalArgs,
    ) -> Self {...}
}
pub struct Unbond(Tx);
impl Unbond {
    /// Build a raw Unbond transaction from the given parameters
    pub fn new(
        validator: Address,
        amount: token::Amount,
        source: Option<Address>,
        args: GlobalArgs,
    ) -> Self {...}
}

pub struct BecomeValidator(Tx);
impl BecomeValidator {
    /// Build a raw Init validator transaction from the given parameters
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        address: Address,
        consensus_key: common::PublicKey,
        eth_cold_key: secp256k1::PublicKey,
        eth_hot_key: secp256k1::PublicKey,
        protocol_key: common::PublicKey,
        commission_rate: Dec,
        max_commission_rate_change: Dec,
        email: String,
        description: Option<String>,
        website: Option<String>,
        discord_handle: Option<String>,
        avatar: Option<String>,
        args: GlobalArgs,
    ) -> Self {...}
}

pub struct UnjailValidator(Tx);
impl UnjailValidator {
    /// Build a raw Unjail validator transaction from the given parameters
    pub fn new(address: Address, args: GlobalArgs) -> Self {...}
}
pub struct DeactivateValidator(Tx);
impl DeactivateValidator {
    /// Build a raw DeactivateValidator transaction from the given parameters
    pub fn new(address: Address, args: GlobalArgs) -> Self {...}
}
pub struct ReactivateValidator(Tx);
impl ReactivateValidator {
    /// Build a raw ReactivateValidator transaction from the given parameters
    pub fn new(address: Address, args: GlobalArgs) -> Self {...}
}

pub struct ClaimRewards(Tx);
impl ClaimRewards {
    /// Build a raw ClaimRewards transaction from the given parameters
    pub fn new(
        validator: Address,
        source: Option<Address>,
        args: GlobalArgs,
    ) -> Self {...}
}

pub struct ChangeMetaData(Tx);
impl ChangeMetaData {
    /// Build a raw ChangeMetadata transaction from the given parameters
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        validator: Address,
        email: Option<String>,
        description: Option<String>,
        website: Option<String>,
        discord_handle: Option<String>,
        avatar: Option<String>,
        commission_rate: Option<Dec>,
        args: GlobalArgs,
    ) -> Self {...}
}

pub struct ChangeConsensusKey(Tx);
impl ChangeConsensusKey {
    /// Build a raw ChangeConsensusKey transaction from the given parameters
    pub fn new(
        validator: Address,
        consensus_key: common::PublicKey,
        args: GlobalArgs,
    ) -> Self {...}
}
pub struct ChangeCommission(Tx);
impl ChangeCommission {
    /// Build a raw ChangeCommission transaction from the given parameters
    pub fn new(validator: Address, new_rate: Dec, args: GlobalArgs) -> Self {...}
}
pub struct Withdraw(Tx);
impl Withdraw {
    /// Build a raw Withdraw transaction from the given parameters
    pub fn new(
        validator: Address,
        source: Option<Address>,
        args: GlobalArgs,
    ) -> Self {...}
}

pub struct Redelegate(Tx);
impl Redelegate {
    /// Build a raw Redelegate transaction from the given parameters
    pub fn new(
        src_validator: Address,
        dest_validator: Address,
        owner: Address,
        amount: Amount,
        args: GlobalArgs,
    ) -> Self {...}
}
```

</document_content></document>

<document index="5">
<source>namada-src/namada-docs/packages/docs/pages/users/ibc.mdx</source>
<document_content>
import { Callout } from 'nextra-theme-docs'

# Transferring assets over IBC

It is possible to make ibc transfers using the Namada cli with the command `namadac ibc-transfer`. The assumed pre-requisites are that a channel has been created and Hermes is running with the proper config on two nodes.

In order to conduct an IBC transfer using Namada's `ibc-transfer` command, we will need to know the `base-dir` and `node` of each instance (and other transfer parameters).
`base-dir` is the base directory of each node, see [base-dir](../operators/ledger/base-directory.mdx) for more information.
`node` is the `rpc_addr` of the relayer.
You can run
```shell
grep "rpc_addr" ${HERMES_CONFIG}
```
to find the address.

<Callout>
 **For the local node ONLY**

To find your ledger address for Chain A, you can run the following command
```bash copy
export BASE_DIR_A="${HERMES}/data/namada-a/.namada"
export LEDGER_ADDRESS_A="$(grep "rpc_address" ${BASE_DIR_A}/${CHAIN_A_ID}/setup/validator-0/.namada/${CHAIN_A_ID}/config.toml)"
```
</Callout>

The [channel ID](../operators/ibc.mdx) for this chain will depend on the order in which one created the channel. Since we have only opened one channel, the `channel-id` is `channel-0`, but as more are created, these increase by index incremented by 1. The channel-id should be communicated by the relayer.

Assuming that the open channel is `channel-0`, you can save it in an environment variable by running
```bash copy
export CHANNEL_ID="channel-0"
```

The inter-blockchain transfers from Chain A can be achieved by
```bash copy
namadac --base-dir ${BASE_DIR_A}
    ibc-transfer \
        --amount ${AMOUNT} \
        --source ${SOURCE_ALIAS} \
        --receiver ${RECEIVER_RAW_ADDRESS} \
        --token ${TOKEN_ALIAS} \
        --channel-id ${CHANNEL_ID} \
        --node ${LEDGER_ADDRESS_A}
```
Where the above variables in `${VARIABLE}` must be substituted with appropriate values. The raw address of the receiver can be found by `namadaw --base-dir ${BASE_DIR_B} address find --alias ${RECEIVER}`.

E.g.
```bash copy
namadac --base-dir ${BASE_DIR_A}
    ibc-transfer \
    --amount 100 \
    --source albert \
    --receiver atest1d9khqw36g56nqwpkgezrvvejg3p5xv2z8y6nydehxprygvp5g4znj3phxfpyv3pcgcunws2x0wwa76 \
    --token nam \
    --channel-id channel-0 \
    --node http://127.0.0.1:27657
```

Once the transaction has been submitted, a relayer will need to relay the packet to the other chain. This is done automatically by the relayer running Hermes. If the packet is never successfully relayed, the funds are returned to the sender after a timeout. See more information in the [specs](https://specs.namada.net/modules/ibc).

## Transferring assets back from Cosmos-SDK based chains

When a transfer has been made to a Cosmos-SDK based chain, the ibc transfer is conducted as above. However, when transferring back from the cosmos-based chain, clearly the `namadac ibc-transfer` command will not work. Instead, you want to use [`gaiad`](https://github.com/cosmos/gaia).

```bash
gaiad tx ibc-transfer transfer transfer ${CHANNEL_ID} ${RECEIVER_RAW_ADDRESS} ${AMOUNT}${IBC_TOKEN_ADDRESS} --from ${COSMOS_ALIAS} --node ${COSMOS_RPC_ENDPOINT} --fees 5000uatom
```

for example:

```bash copy
gaiad tx ibc-transfer transfer transfer channel-0 atest1d9khqw368qcyx3jxxu6njs2yxs6y2sjyxdzy2d338pp5yd35g9zrv334gceng3z9gvmryv2pfdddt4 10ibc/281545A262215A2D7041CE1B518DD4754EC7097A1C937BE9D9AB6F1F11B452DD --from my-cosmos-address --node https://rpc.sentry-01.theta-testnet.polypore.xyz:443 --fees 5000uatom
```

## Shielding transfer
Before `namadac ibc-transfer`, you need to generate a proof of the following IBC transfer for the shielding transfer to the destination Namada. The command `namadac ibc-gen-shielded` generates the proof and outputs a file including required data. In this case, Chain B is the destination chain.
```bash copy
namadac --base-dir ${BASE_DIR_B} ibc-gen-shielded \
  --output-folder-path ${OUTPUT_PATH} \
  --target ${payment_addr_b} \
  --token apfel \
  --amount 100 \
  --port-id transfer \
  --channel-id channel-0 \
  --node ${LEDGER_ADDRESS_B}
```
Then, you can send the token from the source chain by setting the proof in the ICS-20 packet's memo field. The following example is to send tokens from the source Namada (Chain A). The `${memo_path}` should be the file path created by `namadac ibc-gen-shielded` on the destination chain.
```bash copy
namadac --base-dir ${BASE_DIR_A} ibc-transfer \
  --source ${spending_key_a} \
  --receiver ${payment_addr_b} \
  --token apfel \
  --amount 100 \
  --channel-id channel-0 \
  --memo-path ${memo_path} \
  --node ${LEDGER_ADDRESS_A}
```

When the source chain is a Cosmos-SDK based chain, the memo should be set as string with `--memo` option.
```bash copy
memo=$(cat ${memo_path})
gaiad tx ibc-transfer transfer \
  ${CHANNEL_ID} \
  ${RECEIVER_PAYMENT_ADDRESS} \
  ${AMOUNT}${IBC_TOKEN_ADDRESS} \
  --from ${COSMOS_ALIAS} \
  --memo ${memo} \
  --node ${COSMOS_RPC_ENDPOINT} \
  --fees 5000uatom
```

You can do unshielding transfers over IBC without generating a proof.
```bash copy
namadac --base-dir ${BASE_DIR_A} ibc-transfer \
  --source ${spending_key_a} \
  --receiver ${RECEIVER_RAW_ADDRESS} \
  --token nam \
  --amount 100 \
  --channel-id channel-0 \
  --node ${LEDGER_ADDRESS_A}
```

</document_content></document>

<document index="6">
<source>namada-src/namada-docs/packages/specs/pages/modules/ibc.mdx</source>
<document_content>
# IBC integration

* [IBC (Inter-blockchain communication protocol) spec](https://github.com/cosmos/ibc)

## IBC transaction
An IBC transaction [`tx_ibc.wasm`](https://github.com/anoma/namada/blob/a5bad396992e5f66351088bde3bec73d83e769ba/wasm/wasm_source/src/tx_ibc.rs) is provided. We have to set an IBC message to the transaction data corresponding to execute an IBC operation.

The transaction decodes the data to an IBC message and handles IBC-related data, e.g. it makes a new connection ID and writes a new connection end for `MsgConnectionOpenTry`. The operations are implemented in [`IbcActions`](https://github.com/anoma/namada/blob/a5bad396992e5f66351088bde3bec73d83e769ba/core/src/ledger/ibc/mod.rs#L63). The transaction doesn't check the validity for the state changes. IBC validity predicate is in charge of the validity for IBC-related data.

## IBC validity predicate
[IBC validity predicate](https://github.com/anoma/namada/blob/a5bad396992e5f66351088bde3bec73d83e769ba/shared/src/ledger/ibc/vp/mod.rs) checks if an IBC transaction satisfies IBC protocol. When an IBC transaction is executed, i.e. a transaction changes the state of the key that contains [`InternalAddress::Ibc`](https://github.com/anoma/namada/blob/a5bad396992e5f66351088bde3bec73d83e769ba/core/src/types/address.rs#L481), IBC validity predicate (one of the native validity predicates) is executed. For example, if an IBC connection end is created in the transaction, IBC validity predicate validates the creation. If the creation with `MsgConnectionOpenTry` is invalid, e.g. the counterpart connection end doesn't exist, the validity predicate makes the transaction fail.

Specifically, the validity predicate mainly consists of two parts.
* Checking the state changes with the pseudo-execution
* Validating the IBC-related data

The first part is the state change check. It executes the corresponding IBC operation and gets the post-states of the IBC-related data. Then, it checks whether the actual states of IBC-related data by the transaction are equal to the result of the pseudo execution. The second part is the validation of the IBC-related data. It validates that the corresponding data conforms to the IBC protocol. The pseudo-execution and the validation functions are imported from `ibc-rs`.

## Fungible Token Transfer
The transfer of fungible tokens over an IBC channel on separate chains is defined in [ICS20](https://github.com/cosmos/ibc/blob/master/spec/app/ics-020-fungible-token-transfer/README.md).

In Namada, the sending tokens is triggered by a transaction having [MsgTransfer](https://github.com/cosmos/ibc-rs/blob/014fec6958fedcfe9ed6ebfb2d0c28c2cb6487af/crates/ibc/src/applications/transfer/msgs/transfer.rs) as transaction data. A packet including [`PacketData`](https://github.com/cosmos/ibc-rs/blob/014fec6958fedcfe9ed6ebfb2d0c28c2cb6487af/crates/ibc/src/applications/transfer/packet.rs) for the transfer is made from the message in the transaction execution.

A Namada instance receives the tokens by a transaction having [MsgRecvPacket](https://github.com/cosmos/ibc-rs/blob/014fec6958fedcfe9ed6ebfb2d0c28c2cb6487af/crates/ibc/src/core/ics04_channel/msgs/recv_packet.rs) which has the packet including `PacketData` for the transfer.

The sending and receiving tokens in a transaction are validated by not only IBC validity predicate but also [IBC token validity predicate](https://github.com/anoma/namada/blob/e3c2bd0b463b35d66fcc6d2643fd0e6509e03d99/shared/src/ledger/ibc/vp/token.rs). IBC validity predicate validates if sending and receiving the packet is proper. If the transfer is not valid, e.g. an unexpected amount is minted, the validity predicate makes the transaction fail.

A transaction escrowing/unescrowing a token changes the escrow account's balance of the token. The key is `#Multitoken/{token_addr}/balance/#Ibc`. A transaction burning a token decreases the minted balance of the token. The key is `#Multitoken/{token_addr}/balance/minted`. A transaction minting a token increases the minted balance of the token. The key is `#Multitoken/{token_addr}/balance/minted`. `#Multitoken` and `#Ibc` are addresses of [`InternalAddress`](https://github.com/anoma/namada/blob/a5bad396992e5f66351088bde3bec73d83e769ba/core/src/types/address.rs#L473) and actually they are encoded in the storage key. Also, the multitoken validity predicate will be triggered and check the balance changes.

The receiver's account is `#Multitoken/{ibc_token}/balance/{receiver_addr}`. `{ibc_token}` is [`IbcToken(hash)`](https://github.com/anoma/namada/blob/a5bad396992e5f66351088bde3bec73d83e769ba/core/src/types/address.rs#L483) which has a hash calculated with the denomination prefixed with the port ID and channel ID. It is NOT the same as the normal account `#Multitoken/{src_token_addr}/balance/{receiver_addr}` of the token address on the source chain. That's because it should be origin-specific for transferring back to the source chain by binding the token address with the port and channel ID. We can transfer back the received token by setting `{ibc_token}` as `denom` in `MsgTransfer`.

For example, we transfer a token `#my_token` from a user `#user_a` on Chain A to a user `#user_b` on Chain B, then transfer back the token from `#user_b` to `#user_a`. The port ID and channel ID on Chain A for Chain B are `transfer` and `channel_42`, those on Chain B for Chain A are `transfer` and `channel_24`. The denomination in the `PacketData` at the first transfer should be `#my_token`.
1. User A makes `MsgTransfer` as a transaction data and submits a transaction from Chain A
```rust
    let token = Some(Coin {
        denom, // #my_token
        amount: "100000".to_string(),
    });
    let msg = MsgTransfer {
        port_id_on_a, // transfer
        chan_id_on_a, // channel_42
        token,
        sender,       // #user_a
        receiver,     // #user_b
        timeout_height_on_b,
        timeout_timestamp_on_b,
    };
```
2. On Chain A, the specified amount of the token is transferred from the sender's account `#Multitoken/#my_token/balance/#user_a` to the escrow account `#Multitoken/#my_token/balance/#Ibc`
3. On Chain B, `#Multitoken/#my_token/balance/minted` is increased by the amount of the token, and `#Multitoken/{ibc_token}/balance/#user_b`
    - The `{ibc_token}` is made with a hash calculated from a string `transfer/channel_24/#my_token` with SHA256
4. To transfer back, User B makes `MsgTransfer` and submits a transaction from Chain B
```rust
    let token = Some(Coin {
        denom, // {ibc_token}
        amount: "100000".to_string(),
    });
    let msg = MsgTransfer {
        port_id_on_a, // transfer
        chan_id_on_a, // channel_24
        token,
        sender,       // #user_b
        receiver,     // #user_a
        timeout_height_on_b,
        timeout_timestamp_on_b,
    };
```
5. On Chain B, `#Multitoken/{ibc_token}/balance/#user_b` and `#Multitoken/{ibc_token}/balance/minted` are decreased by the amount of the token
6. On Chain A, the amount of the token is transferred from `#Multitoken/#my_token/balance/#Ibc` to `#Multitoken/#my_token/balance/#user_a`

## IBC message
Basically, you don't need to make each IBC message. Namada CLI has `ibc-transfer` to transfer tokens over IBC. For other IBC operations, [Hermes](https://github.com/heliaxdev/hermes/tree/1.3.0-namada) can submit Namada transactions with [Hermes commands](https://hermes.informal.systems/documentation/commands/index.html).
IBC messages are defined in `ibc-rs`. The message should be encoded with Protobuf (NOT with Borsh) as the following code to set it as a transaction data.

```rust
use ibc::tx_msg::Msg;

pub fn make_ibc_data(message: impl Msg) -> Vec<u8> {
    let msg = message.to_any();
    let mut tx_data = vec![];
    prost::Message::encode(&msg, &mut tx_data).expect("encoding IBC message shouldn't fail");
    tx_data
}
```

</document_content></document>

<document index="7">
<source>namada-src/namada/README.md</source>
<document_content>
# Namada

[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](./LICENSE)
![CI Status](https://github.com/anoma/namada/actions/workflows/build-and-test.yml/badge.svg?branch=main)

## Overview

[Namada](http://namada.net) is a Proof-of-Stake L1 for interchain asset-agnostic privacy. Namada uses CometBFT
consensus and enables multi-asset shielded transfers for any native
or non-native asset. Namada features full IBC protocol support,
a natively integrated Ethereum bridge, a modern proof-of-stake
system with automatic reward compounding and cubic slashing, and a
stake-weighted governance signalling mechanism. Users of shielded
transfers are rewarded for their contributions to the privacy set in
the form of native protocol tokens. A multi-asset shielded transfer
wallet is provided in order to facilitate safe and private user
interaction with the protocol.

* Blogpost: [Introducing Namada: Interchain Asset-agnostic Privacy](https://blog.namada.net/introducing-namada-interchain-asset-agnostic-privacy/)

## 📓 Docs

* dev docs: built from [dev mdBook](./documentation/dev/)

## Warning

> Here lay dragons: this codebase is still experimental, try at your own risk!

## 💾 Installing

There is a single command to build and install Namada executables from source (the node, the client and the wallet). This command will also verify that a compatible version of [CometBFT](#dependencies) is available and if not, attempt to install it. Note that currently at least 16GB RAM is needed to build from source.

```shell
make install
```

After installation, the main `namada` executable will be available on path.

To find how to use it, check out the [User Guide section of the docs](https://docs.namada.net/user-guide/index.html).

For more detailed instructions and more install options, see the [Install
section](https://docs.namada.net/user-guide/install/index.html) of the User
Guide.

## ⚙️ Development

```shell
# Build the provided validity predicate and transaction wasm modules
make build-wasm-scripts-docker
```

### Before submitting a PR, pls make sure to run the following

```shell
# Format the code
make fmt

# Lint the code
make clippy
```

## 🧾 Logging

To change the log level, set `NAMADA_LOG` environment variable to one of:

* `error`
* `warn`
* `info`
* `debug`
* `trace`

The default is set to `info` for all the modules, expect for CombetBFT ABCI, which has a lot of `debug` logging.

For more fine-grained logging levels settings, please refer to the [tracing subscriber docs](https://docs.rs/tracing-subscriber/0.2.18/tracing_subscriber/struct.EnvFilter.html#directives) for more information.

To switch on logging in tests that use `#[test]` macro from `test_log::test`, use `RUST_LOG` with e.g. `RUST_LOG=info cargo test -- --nocapture`.

## How to contribute

Please see the [contributing page](./CONTRIBUTING.md).

### Dependencies

The ledger currently requires [CometBFT v0.37.2](https://github.com/cometbft/cometbft/releases/tag/v0.37.2) is installed and available on path. This can be achieved through following [these instructions](https://github.com/cometbft/cometbft/blob/main/docs/guides/install.md)

</document_content></document>

<document index="8">
<source>supplemental-materials/blogposts/speaking-ibc-on-namada</source>
<document_content>
Speaking IBC on Namada
Published 
Sep 11, 2023
6min read
Bengt Lofgren

Let's Talk IBC
This article aims to do two things:
1. Give an introduction to IBC
2. Explain how to use IBC with Namada


What is IBC?
The best analogy I have heard to explain IBC is to think of blockchains as their own sovereign countries, and IBC as a common language. Although each country has its own customs, security enforcements, and capabilities, the common language can allow the two to agree on some common information.

At the heart of every IBC connection lie three fundamental entities: packets, channels, and ports. Ports can be thought of as "what I expect to talk about", packets as "what I'm saying", and channels as "how I'm going to say it". In the context of 2 countries, the "channel of communication" may be to use a common email protocol, a landline phone, snail-mail, or some weekly in-person meeting, and the countries will specify how much communication shall be sent through this mean of communication, and at what times. The port in this case will be the subject of conversation, and therefore the blockchains will have agreed upon what packets "mean anything" on the other side. Packets will be the literal words being exchanged.


It is also important that these blockchains "acknowledge" when one side has received a packet or not, as their states now depend on one another. Further, it is important to know that a packet sent was created in a "valid" manner, and IBC checks for this validity through cryptographic proofs.

These IBC transactions are submitted by an actor called the "relayer", and are validated by the ledger, which keeps an updated "client" to represent the state of the other chain.

How does IBC work on Namada?

Telekinetic Battles rule
Whenever a channel is established, a light client (referred to henceforth as "the client") is constructed (beforehand) on the Namada blockchain that keeps track of the vital information that the blockchain needs about blockchain B in order to verify and execute the packets that are sent through the channel. See MsgUpdateClient for more information on this.

The technicalities are explained in the appendix.

Relaying on Namada
In order to act as a relayer, which involves opening channels, initiating the handshakes, and updating "the Client" it is recommended to use the Heliax fork of Hermes, which is a rust implementation of the IBC relayer (developed by InformalSystems).

You can also find the Hermes official documentation here.

Using IBC on Namada
These technicalities are great for understanding what is happening under the hood, but how exactly could a user make such a transaction on Namada?

The Namada Multitoken
All fungible tokens on Namada share a single validity predicate (VP), called the Multitoken VP, however storage on Namada differentiates IBC assets from non IBC assets. IBC assets are fungible, but only within the chain and port from which they originated. This provides fault isolation between assets that would otherwise seem fungible.

Making an IBC transfer on Namada

IBC Transfer
Now that we've covered the basics, it's time to dive into how a user can proceed with making their first IBC transfer.

The namada client (namadac) implements the function ibc-transfer which conducts the IBC transfer message appropriately. The arguments of the functions are listed in the example funciton below:

namadac ibc-transfer \
--token NAM \
--amount 100 \
--source albert \
--receiver atest1d9khqw36g56nqwpkgezrvvejg3p5xv2z8y6nydehxprygvp5g4znj3phxfpyv3pcgcunws2x0wwa76 \
--signing-keys albert \
--channel-id channel-0 \
--node 127.0.0.1:27657
Things to note:
The source in this case is any address on the origin chain. This can be an alias for an address that is stored in the wallet (in this case Albert), or it can be the raw address itself. However, for the "receiver address", it needs to be the raw address as specified on the destination chain. If not correctly specified, funds may be lost.

The channel-id will correspond to a channel-id that has already been established by a relayer at some point in the past. The node argument specifies the IP address and port for the node of the source chain. This is especially useful when interacting with two different chains using the same Namada client.

Once this transaction has been executed, a CometBFT event is emitted and a pending execution is stored on chain in storage, that a relayer can relay at any time. Balances are deducted from the source of the account at this point, but the deduction is not finalised until an acknowledgement of the event being relayed successfully is received on chain.

Once the relayer has provided a MsgAcknowledgement with the respective proof of a verified state change on chain-B, and Namada verifies it, the state change is finalised on Namada. Should no relayer provide the proof confirming the state change on chain-B, the state change is left as it is in a pending state until Namada either receives a MsgTimeoutOnClose or a MsgAcknowledgement.

Note that IBC channels for port ICS20 transfers cannot be closed, so either of the two above must occur at some point.

What about shielded actions?
So, what is a shielded action in the first place?

A shielded action is an IBC action in which the users' funds originate from and/or end up in the shielded pool.

For specific chains, such as Osmosis, a specific port will be set up for this purpose, which calls the appropriate functions on each chain, and agree on what packets and therefore data can be sent across the channel and end up being valid IBC actions.

The memo field is the essential piece of the puzzle which will allow for this, as it can allow for the destination address to be a shielded address, and although the internal address that initially receives the funds is a transparent account, it can exist for the sole responsibility of routing the funds to shielded addresses specified in the memo section.


Conclusion
IBC is an essential part of Namada's mission to provide a multichain data protection solution for users across the blockchain ecosystem.

In this sense, IBC becomes arguably Namada's greatest feature, as it transforms Namada from another competing solution to a cooperative one, to be interoperable with the existing projects like Osmosis, Cosmos Hub, Akash Network, etc. but also future ones, such as Penumbra, DYDX, and perhaps even Zcash, should the community choose to go down that path.

Appendix
"The Client"
The IBC client on Namada consists of 2 parts:

ClientState
ConsensusState
ClientState
The ClientState stores information about the other chain, including but not limited to the:

chain-id
latest_height - latest block height
trust_threshold - fraction of (weighted) signatures from validators on the other chain
proof_specs - specifies the structure of the proof that a relayer must provide in order for any IBC transaction to be considered valid by Namada. Namada conforms to the ICS023 specification . This technicality is what hinders byzantine relayers from affecting state maliciously. In this way, the security of the interchain network remains in tact (although liveness may be affected until an honest relayer steps in to provide a valid proof).
ConsensusState
root_hash - the merkle tree root hash
next_validator_hash - the hash of the concatenation of the validator addresses for the next epoch
timestamp - the time of the last update
The values of the these fields are updated with each IBC transaction, and each such transaction is submitted (and paid for) by the relayer.

The Handshake
In order to establish a connection, a 4-way handshake is made between Namada and Chain B, which establishes the client and ensures that a common language is agreed upon. The handshake procedure for Namada is implemented to conform with the definitions specified in ICS 3 and ICS 4.

The IBC validity predicate (VP)
The IBC validity predicate exists in order to verify any IBC-related state execution on Namada.
There are two main things that the IBC validity predicate verifies:

Pseudo-execution verification.
In a pseudo-environment (not changing true storage in any way), the execution is checked so that the resulting state change is in agreement with the IBC tx. An important distinction is that this step does not check the validity of the IBC-related data in any other way. This check is mainly needed for when arbitrary WASM execution is allowed on chain, and there is no whitelist.
2. Verifying that the IBC tx is provided in a valid manner. This includes:

A valid vector-commitment of chain-B's state is attached
The message is valid (not timed out)
The channel through which the message is sent is indeed open
The IBC VP on Namada is what guarantees the safety of IBC transactions, as mentioned earlier in this article.
</document_content></document>

<document index="9">
<source>supplemental-materials/hermes-config.toml</source>
<document_content>
# HERMES config.toml for configuring IBC token transfers.
[global]
#log_level = 'info'
log_level = 'trace'

[mode]
 
[mode.clients]
enabled = true
refresh = true
misbehaviour = true
 
[mode.connections]
enabled = false
 
[mode.channels]
enabled = false
 
[mode.packets]
enabled = true
clear_interval = 10
clear_on_start = false
tx_confirmation = true
 
[telemetry]
enabled = false
host = '127.0.0.1'
port = 3001


[[chains]]
id = 'shielded-expedition.88f17d1d14'  # set your chain ID
type = 'Namada'

trusting_period = '4752s'
rpc_timeout = "60s"

rpc_addr = 'http://127.0.0.1:26657'  # set the IP and the port of the chain
grpc_addr = 'http://127.0.0.1:9090'  # not used for now
account_prefix = ''  # not used
memo_prefix = "tpknam1qz7z09ds674wlyfl6upvl2e6jtuus7lfp2"
key_name = 'relayer2'  # The key is an account name you made
store_prefix = 'ibc' 

	[chains.gas_price]
		price = 0.001
		denom = "tnam1qxvg64psvhwumv3mwrrjfcz0h3t3274hwggyzcee" 
			# the denom should be a raw token address

	[chains.event_source]
		mode = "push"
		#mode = "pull"
		url = "ws://127.0.0.1:26657/websocket"
		batch_delay = "500ms"

	[chains.packet_filter]
		policy = 'allow'
		list =	[
				['transfer', "channel-668"],
				['transfer', "channel-700"]
				]



[[chains]]
type = "CosmosSdk"
id = "osmo-test-5"
rpc_addr = "https://rpc.osmotest5.osmosis.zone/"
grpc_addr = "https://grpc.osmotest5.osmosis.zone/"
rpc_timeout = "60s"
trusted_node = false
account_prefix = "osmo"
#key_name = "relayer-o"
key_name = "OSMOSIS-RELAYER-ADDRESS"
key_store_type = "Test"
store_prefix = "ibc"
default_gas = 100000
max_gas = 4000000
gas_multiplier = 1.1
max_msg_num = 30
max_tx_size = 180000
max_grpc_decoding_size = 33554432
clock_drift = "5s"
max_block_time = "30s"
ccv_consumer_chain = false
memo_prefix = "ForestNode"
sequential_batch_tx = false

	[chains.event_source]
	mode = "push"
	url = "wss://rpc.osmotest5.osmosis.zone:433/websocket"
	batch_delay = "500ms"

	[chains.trust_threshold]
	numerator = "1"
	denominator = "3"

	[chains.gas_price]
	price = 0.025
	denom = "uosmo"

	#[chains.packet_filter.min_fees]

	[chains.packet_filter]
		policy = 'allow'
		list =	[
				['transfer', "channel-6162"],
				['transfer', "channel-6185"]
				]


	[chains.address_type]
	derivation = "cosmos"

	[tracing_server]
	enabled = false
	port = 5555
</document_content></document>

<document index="10">
<source>supplemental-materials/funding_proposal.json</source>
<document_content>
{
   "proposal": {
     "id": 336,
     "content": {
       "title": "Staying positive",
       "authors": "namada@forestnode.xyz",
       "discussions-to": "🖐",
       "created": "2024-03-13T23:59:01Z",
       "license": "MIT",
       "abstract": "Cut the massive approved 200M spending on tnam1qqnarl4h6dsy4jchy0tcxakh286ec03weyfnks6e steward down to 5k. Also, as we've lost almost all our NAANs to double-vote-based slashing, not to beg for NAAN's from you every week, we kindly ask of you to approve the testnet funding.",
       "motivation": "Testing out the Steward functionality of the Namada and having fun while at it.",
       "details": "Love yall! ❤",
       "requires": ""
     },
     "author": "tnam1qxy9qez7f63rly36suw08z65ur9e2lfspcgzp4uy",
     "voting_start_epoch": 34,
     "voting_end_epoch": 36,
     "grace_epoch": 38
   },
  
"data" :
    {
        "continuous" : 
            [
                {
                    "Internal": 
                            {
                                "amount": "200000000000",
                                "target": "tnam1qqz3rzekvxpdlyyz47g28e3jjq8x252t8542rhdk"
                            }
                }
                ,
                {
                    "Internal": 
                            {
                                "amount": "5000000000",
                                "target": "tnam1qqnarl4h6dsy4jchy0tcxakh286ec03weyfnks6e"
                            }
                }
                ,
                {
                    "Ibc": 
                        {
                            
                            "amount": "500000000",
                            "target": "osmo1xl7pamcuf8pnnrx58kq4gyuzwk6hg67r87eujw",
                            "port_id": "transfer",
                            "channel_id": "channel-700"
                        }
                }

            ],
        "retro" : 
            [
                {
                    "Internal": 
                        {
                            "amount": "300000000000",
                            "target": "tnam1qqz3rzekvxpdlyyz47g28e3jjq8x252t8542rhdk"
                        }
                }
                ,
                {
                    "Ibc": 
                        {
                            
                            "amount": "1000000000",
                            "target": "osmo1xl7pamcuf8pnnrx58kq4gyuzwk6hg67r87eujw",
                            "port_id": "transfer",
                            "channel_id": "channel-700"
                        }
                }

            ]
    }  

        
 }

</document_content></document>

<document index="11">
<source>namada-src/namada-docs/packages/docs/pages/networks/testnets/testnet-history.mdx</source>
<document_content>
import { Callout } from 'nextra-theme-docs'

# Upgrades
This page covers all installation steps required by various upgrades to testnets.


## Latest Upgrade

## Namada shielded expedition 2 `v0.31.8` upgrade

In order to upgrade to the latest version of the Namada protocol, please follow the steps from [this hackmd](https://hackmd.io/EBTtfPiZT7yoRjxYRcbiPQ)

## Shielded expedition

- Namada Shielded expedition 2:
  - From date: 6th of February 2024 18:00 UTC
  - Namada protocol version: `v0.31.9`
  - Cometbft version: `0.37.2`
  - CHAIN_ID: `shielded-expedition.88f17d1d14`

- Namada Shielded expedition 1 (offline):
  - From date: 1st of February 2024 18:00 UTC
  - Namada protocol version: `v0.31.0`
  - Cometbft version: `0.37.2`
  - CHAIN_ID: `shielded-expedition.3d767ac5d5`
  
## Latest Testnet

- Namada public testnet 15 (offline):
  - From date: 18th of December 2023 17:00 UTC
  - Namada protocol version: `v0.28.1`
  - Cometbft version: `0.37.2`
  - CHAIN_ID: `public-testnet-15.0dacadb8d663`


## Testnet History Timeline

- Namada public testnet 14 (offline):
  - From date: 5th of October 2023 17:00 UTC
  - Namada protocol version: `v0.23.0`
  - Cometbft version: `0.37.2`
  - CHAIN_ID: `public-testnet-14.5d79b6958580`

- Namada public testnet 13 (offline):
  - From date: 12th of September 2023 17:00 UTC
  - Namada protocol version: `v0.22.0`
  - Cometbft version: `0.37.2`
  - CHAIN_ID: `public-testnet-13.facd514666d5`

- Namada public testnet 12:
  - From date: 17th of August 2023 17.00 UTC
  - Namada protocol version: `v0.21.1`
  - Cometbft version: `0.37.2`
  - CHAIN_ID: `public-testnet-12.fedec12f3428`

- Namada public testnet 11:
  - From date: 2nd of August 2023 17.00 UTC
  - Namada protocol version: `v0.20.1`
  - Cometbft version: `0.37.2`
  - CHAIN_ID: `public-testnet-11.cc649ddd49b0`

- Namada public testnet 10:
  - From date: 29th of June 2023 17.00 UTC
  - Namada protocol version: `v0.17.5`
  - Cometbft version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-10.3718993c3648`

- Namada public testnet 9:
  - From date: 20th of June 2023 17.00 UTC
  - Namada protocol version: `v0.17.3`
  - Cometbft version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-9.3718993c3648`

- Namada public testnet 8:
  - From date: 17th of May 2023 17.00 UTC
  - Namada protocol version: `v0.15.3`
  - Tendermint version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-8.0.b92ef72b820`

- Namada public testnet 7:

  - From date: 24th of April 2023 17.00 UTC
  - Namada protocol version: `v0.15.1`
  - Tendermint version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-7.0.3c5a38dc983`

- Namada public testnet 6:

  - From date: 29th of March 2023 17.00 UTC
  - Namada protocol version: `v0.14.3`
  - Tendermint version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-6.0.a0266444b06`

- Namada public testnet 5:

  - From date: 15th of March 2023
  - Namada protocol version: `v0.14.2`
  - Tendermint version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-5.0.d25aa64ace6`

- Namada public testnet 4:

  - From date: 22nd of February 2023
  - Namada protocol version: `v0.14.1`
  - Tendermint version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-4.0.16a35d789f4`

- Namada public testnet 3 hotfix (did not suffice):

  - From date: 13th of February 2023
  - Namada protocol version: `v0.13.4`
  - Tendermint version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-3.0.81edd4d6eb6`

- Namada public testnet 3:

  - From date: 9th of February 2023
  - Namada protocol version: `v0.13.3`
  - Tendermint version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-3.0.81edd4d6eb6`

- Namada public testnet 2.1.2 hotfix:

  - From date: 25th of January 2023
  - Namada protocol version: `v0.13.3`
  - Tendermint version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-2.1.4014f207f6d`

  Due to a bug, a [hotfix](https://github.com/anoma/namada/releases/tag/v0.13.3) was released.
  This needed to be installed and applied before `18:00:00 UTC` on `2023-01-25`.

- Namada public testnet 2.1.2:

  - From date: 24th of January 2023
  - Namada protocol version: `v0.13.2`
  - Tendermint version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-2.1.4014f207f6d`

- Namada public testnet 2.1:
  - From date: 17th of January 2023
  - Namada protocol version: `v0.13.1-hardfork` (hardfork)
  - Tendermint version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-2.0.2feaf2d718c`

The above hardfork was meant to take effect on Block Height `37370`, but some issues arose. You can read more [here](https://blog.namada.net/namada-testnet-v0-13-0-upgrade-postmortem).

- Namada public testnet 2.0:

  - From date: 12th of January 2023
  - Namada protocol version: `v0.13.0`
  - Tendermint version: `v0.1.4-abciplus`
  - CHAIN_ID: `public-testnet-2.0.2feaf2d718c`

- Namada public testnet 1:
  - Namada protocol version: `v0.12.0`
  - Tendermint version: `v0.1.4-abciplus`
  - Genesis time: 20th of December 2022 at 17:00 UTC
  - CHAIN_ID: `public-testnet-1.0.05ab4adb9db`


## Upgrade History:


***19/05/2023*** `public-testnet-8` hot-fix

Due to some issues with our mempool validation, the testnet halted starting at block height `8073`. We fixed this issue and released a hot-fix version to a subset of the validators. This was sufficient to keep the testnet going. It did require some validators to resync the testnet.
The chain was launched with chain-id `public-testnet-8.0.b92ef72b820`

***24/04/2023*** `public-testnet-7` (offline)

The testnet launched on 24/04/2023 at 17:00 UTC with the genesis validators from `public-testnet-7`. It launches with [version v0.15.1](https://github.com/anoma/namada/releases/tag/v0.15.1) 
The chain was launched with chain-id `public-testnet-7.0.3c5a38dc983`.

The intended fix to solve the storage issue was only partially solved. This led to `v0.15.3` which intended to fix these issues.


***13/02/2023*** `public-testnet-3`

On *09/02/2023* the Namada chain `public-testnet-3` halted due to a bug in the Proof of Stake implementation when handling an edge case. Over the weekend, the team were able to fix and test a new patch that resolves the issue at hand. On *13/02/2023 11:30 UTC*, we were able to recover the network by having internal validators upgrade to the new patch. We are now calling on validators to upgrade to the new testnet as well, which will allow you to interact with the recovered chain.

**Upgrading**
1. Begin by stopping all instances of the namada node
```bash copy
killall namadan
```
2. Build the new tag (or download the binaries [here](https://github.com/anoma/namada/releases/tag/v0.13.4))
```bash copy
cd namada
export NAMADA_TAG=v0.13.4
make build-release
```
3. Copy the new binaries to path. More in depth instructions can be found at [here](./environment-setup.mdx)
4. Once this has been completed, **the node must tesync from genesis** (see below)

**How to resync from genesis:**
1. As a precautionary measure, make a backup of your pregenesis keys
```bash copy
mkdir backup-pregenesis && cp -r .namada/pre-genesis backup-pregenesis/
```
2. Delete the relevant folder in .namada
```bash copy
rm -r .namada/public-testnet-3.0.81edd4d6eb6
rm .namada/public-testnet-3.0.81edd4d6eb6.toml
```
WARNING: Do not delete the entire `.namada` folder, as it contains your pre-genesis keys. If this is accidentally done, you will have to copy over the backup-pregenesis file. 

3. Rejoin the network
```bash copy
export CHAIN_ID="public-testnet-3.0.81edd4d6eb6"
namada client utils join-network \
--chain-id $CHAIN_ID --genesis-validator $ALIAS
```
4. Run the node. One can simply run the ledger again using the familiar command
```bash copy
  NAMADA_CMT_STDOUT=true namada node ledger run
  ```

Please reach out with any questions if you have any. This upgrade can be done asynchronously, but if you wish to continue validating the chain and testing our features, you must execute the above steps.

### Hotfix for Testnet `public-testnet-2.1.4014f207f6d`

***27/01/2023***

The hotfixed testnet ran during the week, when a strange bug caused the network to stall. The core team spent 1 week investigating the cause of the bug, and the result they found was quite interesting. If you are curious about the specific details of the bug, please have a read through Ray's blog post [here](https://blog.namada.net/explaining-the-namada-0-13-3-consensus-fork/). 

***25/01/2023***

At around 06:15 UTC 25/01/2023, a validator with very little stake was scheduled to become part of the active validator set. From this tx, we discovered a conversion bug between the Namada state machine and Cometbft, which lead to a crash in the node.
A patch was released [v0.13.3](https://github.com/anoma/namada/releases/tag/v0.13.3) in order to deal with this issue.


***23/01/2023***

A new testnet was released before the fortnightly testnet release schedule due to the below hardfork not working as intended. Follow the steps in [setting up a new testnet](./environment-setup.mdx)

### Hardfork v0.13.1

This hardfork is set to be instantiated at block height `37370`, which is predicted to occur at around 17.00 UTC on 18/01/2023.

**Requirements to do before 17.00 UTC 18/01/2023**

In order to install this upgrade, a user or validator must 

1. [Download the binaries](https://github.com/anoma/namada/releases/tag/v0.13.1-hardfork) or install them [from source](https://github.com/anoma/namada/releases/tag/v0.13.1-hardfork)

2. Ensure the versions are correct, such that `<PATH_TO_BINARY>/namada --version` is `v0.13.1-hardfork` 

3. Interrupt the `namada ledger` by the interrupt command `^C`

4. Install the binaries onto `$PATH` (this depends on your machine). This must be done after interrupting the ledger, as otherwise an error is likely to be thrown.

5. As soon as possible, restart the ledger by running `NAMADA_CMT_STDOUT=true namada node ledger run`

The ledger will then update correctly at the correct height. In order to ensure a smooth fork, please do this as soon as possible.


</document_content></document>

<document index="12">
<source>namada-src/namada-docs/packages/docs/pages/networks/testnets/faq.mdx</source>
<document_content>
# Namada FAQ

### **Q: How do I join as a validator post-genesis?**

**A:** Joining as a validator post genesis can be done following [these instructions](../../operators/validators/validator-setup.mdx).

### **Q: How do I use the Faucet?**
    
**A:** The faucet can be accessed [here](https://faucet.heliax.click)

### **Q: Where can I see the available tokens on the Faucet?**
    
**A:** The following list of tokens are available to withdraw from the faucet:
    
`NAM, DOT, ETH, BTC`

There are a few more, but we leave it to you as a challenge to find out which these are 🤔 
HINT: `namadac balance`

### **Q: How do I use the Ethereum Bridge?**
    
**A:** The Ethereum Bridge is not yet implemented as of 0.23.0 Keep an eye on the [Changelog](https://github.com/anoma/namada/tree/main/.changelog) 👀 to see when it will be officially released.

### **Q: How can I make an IBC transfer?**
    
**A:** As of `v0.23.1` you can now follow the docs [here!](../../users/ibc.mdx)

### **Q: What requirements do I need to be a User/Validator?**

**A:**  See [hardware requirements](../../operators/hardware.mdx).

In order to build binaries from source, at least 16GB RAM will be required.

### **Q: Where can I find the binaries to run Namada if I do not want to build from source?**

**A:** See [Installing Namada from binaries](../../introduction/install/binaries.mdx)

</document_content></document>

<document index="13">
<source>namada-src/namada-docs/packages/specs/pages/base-ledger/block-space-allocator.mdx</source>
<document_content>
import { Callout } from 'nextra-theme-docs'
import blockSpaceEx from './images/block-space-allocator-example.svg'
import blockSpaceBins from './images/block-space-allocator-bins.svg'

# Block space allocator

<Callout type="info">
Note that the DKG scheme for front-running prevention is not a feature included in the first release of Namada. 
The block-space-allocator infrastructure still exists, but the decryption is hardcoded and does not require validator coordination.
</Callout>

Block space in CometBFT is a resource whose management is relinquished to the 
running application. This section covers the design of an abstraction that 
facilitates the process of transparently allocating space for transactions in a 
block at some height $H$, whilst upholding the safety and liveness properties 
of Namada.

## On block sizes in CometBFT and Namada

[Block sizes in CometBFT](https://github.com/cometbft/cometbft/blob/main/spec/abci/abci%2B%2B_app_requirements.md#blockparamsmaxbytes) (configured through the `MaxBytes` consensus 
parameter) have a minimum value of $1\ \text{byte}$, and a hard cap of $100\ 
\text{MiB}$, reflecting the header, evidence of misbehavior (used to slash 
Byzantine validators) and transaction data, as well as any potential protobuf 
serialization overhead. Some of this data is dynamic in nature (e.g. 
evidence of misbehavior), so the total size reserved to transactions in a block 
at some height $H_0$ might not be the same as another block's, say, at some 
height $H_1 : H_1 \ne H_0$. During CometBFT's `PrepareProposal` ABCI phase, 
applications receive a $MaxTxBytes$ parameter whose value already accounts for 
the total space available for transactions at some height $H$. Namada does not 
rely on the `MaxTxBytes` parameter of `RequestPrepareProposal`; instead, 
app-side validators configure a `MaxProposalSize` parameter at genesis (or
through governance) and set CometBFT blocks' `MaxBytes` parameter to its 
upper bound.

## Transaction batch construction

During CometBFT's `PrepareProposal` ABCI phase, Namada (the ABCI server) is 
fed a set of transactions $M := \{\ tx\ |\ tx\text{ in CometBFT's mempool}\ 
\}$, whose total combined size (i.e. the sum of the bytes occupied by each $tx 
: tx \in M$) may be greater than `MaxProposalBytes`. Therefore, consensus round 
leaders are responsible for selecting a batch of transactions $P$ whose total 
combined bytes $P_{Len} \le $ `MaxProposalBytes`.

To stay within these bounds, block space is **allotted** to different kinds of 
transactions: decrypted, protocol and encrypted transactions. Each kind of 
transaction gets about $\frac{1}{3} MaxProposalBytes$ worth of allotted space, 
in an abstract container dubbed the `TxBin`. A transaction $tx : tx \in M$ may 
be **dumped** to a `TxBin`, resulting in a successful operation, or an error, 
if $tx$ is **rejected** due to lack of space in the `TxBin` or if $tx$'s size 
**overflows** (i.e. does not fit in) the `TxBin`. Block proposers continue 
dumping transactions from $M$ into a `TxBin` $B$ until a rejection error is 
encountered, or until there are no more transactions of the same type as $B$'s 
in $M$. The `BlockSpaceAllocator` contains three `TxBin` instances, responsible 
for holding decrypted, protocol and encrypted transactions.

<img
  src={blockSpaceBins.src}
  alt="block space allocator tx bins"
  height="400"
  width="500"
  style={{ display: 'block', margin: '0 auto' }} />

During occasional Namada protocol events, such as DKG parameter negotiation, 
all available block space should be reserved to protocol transactions, 
therefore the `BlockSpaceAllocator` was designed as a state machine, whose 
state transitions depend on the state of Namada. The states of the 
`BlockSpaceAllocator` are the following:

1. `BuildingDecryptedTxBatch` - As the name implies, during this state the 
decrypted transactions `TxBin` is filled with transactions of the same type. 
Honest block proposers will only include decrypted transactions in a block at a 
fixed height $H_0$ if encrypted transactions were available at $H_0 - 1$. The 
decrypted transactions should be included in the same order of the encrypted 
transactions of block $H_0 - 1$. Likewise, all decrypted transactions available 
at $H_0$ must be included.
2. `BuildingProtocolTxBatch` - In a similar manner, during this 
`BlockSpaceAllocator` state, the protocol transactions `TxBin` is populated 
with transactions of the same type. Contrary to the first state, allocation 
stops as soon as the respective `TxBin` runs out of space for some 
$tx_{Protocol} : tx_{Protocol} \in M$. The `TxBin` for protocol transactions is 
allotted half of the remaining block space, after decrypted transactions have 
been **allocated**.
{/* TODO: The ordering of these steps is a bit unintuitive. Feels like we should begin with `BuildingEncryptedTx` */}
{/* TODO: The WithoutEncryptedTxs is not clear. Are these special types of protocol txs? */}
3. `BuildingEncryptedTxBatch` - This state behaves a lot like the previous 
state, with one addition: it takes a parameter that guards the encrypted 
transactions `TxBin`, which in effect splits the state into two sub-states. 
When `WithEncryptedTxs` is active, block space is filled with encrypted 
transactions (as the name implies). Orthogonal to this mode of operation, there 
exists `WithoutEncryptedTxs`, which, as the name implies, does not allow encrypted 
transactions to be included in a block. The `TxBin` for encrypted transactions 
is allotted $\min(R,\frac{1}{3} MaxProposalBytes)$ bytes, where $R$ is the 
block space remaining after allocating space for decrypted and protocol 
transactions.
4. `FillingRemainingSpace` - The final state of the `BlockSpaceAllocator`. Due 
to the short-circuit behavior of a `TxBin`, on allocation errors, some space 
may be left unutilized at the end of the third state. At this state, the only 
transaction types that are left to fill the available block space are
encrypted and protocol transactions, but encrypted transactions are forbidden
to be included, to avoid breaking their invariant regarding
allotted block space (i.e. encrypted transactions can only occupy up to
$\frac{1}{3}$ of the total block space for a given height $H$). As such,
only protocol transactions are allowed at the fourth and final state of
the `BlockSpaceAllocator`.

For a fixed block height $H_0$, if at $H_0 - 1$ and $H_0$ no encrypted 
transactions are included in the respective proposals, the block decided for 
height $H_0$ will only contain protocol transactions. Similarly, since at most 
$\frac{1}{3}$ of the available block space at a fixed height $H_1$ is reserved 
to encrypted transactions, and decrypted transactions at $H_1+1$ will take up 
(at most) the same amount of space as encrypted transactions at height $H_1$, 
each transaction kind's `TxBin` will generally get allotted about $\frac{1}{3}$ 
of the available block space.

### Example

Consider the following diagram:

<img
  src={blockSpaceEx.src}
  alt="block space allocator example"
  height="400"
  width="600"
  style={{ display: 'block', margin: '0 auto' }}
/>

We denote `D`, `P` and `E` as decrypted, protocol and encrypted transactions, 
respectively.

* At height $H$, block space is evenly divided into three parts, one for each 
kind of transaction type.
* At height $H+1$, no encrypted transactions are included in the proposal, 
therefore protocol transactions are allowed to take up to $\frac{2}{3}$ of the 
available block space.
* At height $H+2$, no encrypted transactions are included either. Notice that 
no decrypted transactions were included in the proposal, since at height $H+1$ 
no encrypted transactions were committed. In sum, only protocol 
transactions are included in the proposal for the block with height $H+2$.
* At height $H+3$, encrypted transactions are proposed once more. Just like in 
the previous scenario, no decrypted transactions are available. Encrypted 
transactions are capped at $\frac{1}{3}$ of the available block space, so the 
remaining $\frac{1}{2} - \frac{1}{3} = \frac{1}{6}$ of the available block 
space is filled with protocol transactions.
* At height $H+4$, allocation returns to its normal operation, thus block space 
is divided in three equal parts for each kind of transaction type.

## Transaction batch validation

Batches of transactions proposed during ABCI's `PrepareProposal` phase are 
validated at the `ProcessProposal` phase. The validation conditions are 
relaxed, compared to the rigid block structure imposed on blocks during 
`PrepareProposal` (i.e. with decrypted, protocol and encrypted transactions 
appearing in this order, as [examplified above](#example)). 

Define $H$ as the height of block $B$ currently being decided through Tendermint's 
consensus mechanism. Define $P$ as the batch of transactions proposed at $H$ as $B$'s 
payload and define $V$ as the current set of active validators. To vote on $P$, each 
validator $v \in V$ checks that:

* The length of $P$ in bytes, defined as $P_{Len} := \sum_{tx \in 
P} \text{size\_of}(tx)$, is not greater than `MaxProposalBytes`.
* $P$ does not contain more than $\frac{1}{3}$ `MaxProposalBytes` worth of 
encrypted transactions.
    - While not directly checked, the batch construction invariants guarantee 
that decrypted transactions are constrained to occupy up to $\frac{1}{3} $
`MaxProposalBytes` bytes of the available block space at $H$ (or any block 
height, in fact).
* All decrypted transactions from $H-1$ have been included in the proposal 
$P$, for height $H$.
* No encrypted transactions were included in the proposal $P$, if no
encrypted transactions should be included at $H$.

<Callout type="info">
N.b. the conditions to reject encrypted transactions are not specced out, and would be necessary should Namada incorporate the DKG scheme
</Callout>

Should any of these conditions not be met at some arbitrary round $R$ of $H$, 
all honest validators $V_h : V_h \subseteq V$ will reject the proposal $P$. 
Byzantine validators would be permitted to re-order the layout of $P$ typically 
derived from the [`BlockSpaceAllocator`](#transaction-batch-construction) $A$, 
under normal operation, however this should not be a compromising factor of the 
safety and liveness properties of Namada. The rigid layout of $B$ is simply a 
consequence of $A$ allocating in different phases.

### On validator set updates

Validator set updates, one type of protocol transactions decided through BFT 
consensus in Namada, are fundamental to the liveness properties of the Ethereum 
bridge. Unfortunately, achieving a quorum of signatures for a validator set update between two adjacent block heights 
through ABCI alone is not feasible. Hence, the Ethereum bridge is not a live 
distributed system, since there is the possibility to cross an epoch boundary 
without constructing a valid proof for some validator set update. In practice, 
however, it is nearly impossible for the bridge to get "stuck", as validator 
set updates are eagerly issued at the start of an epoch, whose length should be 
long enough for consensus(*) to be reached on a single validator set update.

(*) Note that consensus was used loosely here to refer to the process of 
acquiring a quorum (e.g. more than $\frac{2}{3}$ of voting power, by stake) of 
signatures on a single validator set update. "Chunks" of a proof (i.e. 
individual votes) are decided and batched together, until a complete proof is 
constructed.

Validator set updates are covered in more detail in [the Ethereum bridge section](../modules/ethereum-bridge.mdx).

## Governance

Governance parameter update proposals for $MaxProposalBytes_H$ that take effect 
at $H$, where $H$ is some arbitrary block height, should be such that
$MaxProposalBytes_H \ge \frac{1}{3} MaxProposalBytes_{H-1}$, to leave enough
room for all decrypted transactions from $H-1$ at $H$. Subsequent block heights
$H' : H' > H$ should eventually lead to allotted block space converging to about
$\frac{1}{3} MaxProposalBytes_H$ for each kind of transaction type.

</document_content></document>

<document index="14">
<source>namada-src/namada-docs/packages/specs/pages/base-ledger/consensus.mdx</source>
<document_content>
# Consensus

Namada uses [CometBFT](https://github.com/cometbft/cometbft/) (nee Tendermint Go) through the [cometbft-rs](https://github.com/heliaxdev/tendermint-rs) (nee tendermint-rs) bindings in order to provide peer-to-peer transaction gossip, Byzantine fault tolerant (BFT) consensus, and state machine replication for Namada's custom state machine. CometBFT implements the Tendermint consensus algorithm, which you can read more about [here](https://arxiv.org/abs/1807.04938).

## The benefits of using CometBFT

CometBFT, coupled with a cryptoeconomic voting power allocation mechanism called "proof of stake", is designed so that that non-colluding validators acting in their (economic) self interest will follow the consensus algorithm in a predictable manner.

Using the CometBFT consensus algorithm comes with a number of benefits including:

- Fast finality 
    - CometBFT achieves fast and deterministic finality, meaning that once a block is committed to the blockchain, it is irreversible. This is crucial for applications which rely on settled transactions that cannot be rolled back, and enables efficient, low-latency interoperability.
- Inter-blockchain communication system (IBC)
    - Interoperability with all other IBC-supporting chains, such as [Osmosis](https://osmosis.zone), the [Cosmos Hub](https://cosmos.network), and [Noble](https://nobleassets.xyz/).
- Battle tested
    - The entire Cosmos ecosystem has been using CometBFT (nee Tendermint) for years.
- Customisable
    - Allows the configuration of various parameters, including the ability to implement a custom proof of stake algorithm (as Namada does).
</document_content></document>

<document index="15">
<source>namada-src/namada-docs/packages/specs/pages/base-ledger/execution.mdx</source>
<document_content>
# Execution

The Namada ledger execution system is based on an initial version of the Anoma execution model. The system implements a generic computational substrate with WASM-based transactions and validity predicate verification. It is on top of this system which specific features of Namada such as IBC, proof-of-stake, and the MASP are built.

## Validity predicates

Conceptually, a validity predicate (VP) is a boolean function which takes four inputs: 

1. The transaction itself (certain parts of the transaction are sometimes analyzed in the VP logic, such as MASP proofs)
2. The addresses that are involved with that specific VP
3. The storage state prior to the transaction execution
4. The storage state after the transaction execution

A transaction may modify any data in storage, which is partitioned into different areas ("accounts"), each associated with a VP. Upon transaction execution, the VPs associated with the accounts whose storage has been modified are invoked to verify the transaction. If any of them reject the transaction, all of its storage modifications are discarded; if all accept, the storage modifications are written.

## Namada ledger

The Namada ledger is built on top of [CometBFT v0.37](https://docs.cometbft.com/v0.37/spec/)'s [ABCI](https://docs.cometbft.com/v0.37/spec/abci/) interface with a slight deviation from the ABCI convention: in Namada, the transactions are currently *not* being executed in ABCI's [`DeliverTx` method](https://docs.cometbft.com/v0.37/spec/abci/abci++_methods#delivertx), but rather in the [`EndBlock` method](https://docs.cometbft.com/v0.37/spec/abci/abci++_methods#endblock). {/* TODO: I don't know what we want to say about the above. Maybe delete the below sentence entirely? */} 
The reason for this is to prepare for future DKG and threshold decryption integration. 

The ledger features an account-based system (in which UTXO-based systems such as the MASP can be internally implemented as specific accounts), where each account has a unique address and a dynamic key-value storage sub-space. Every account in Namada is associated with exactly one validity predicate. Fungible tokens, for example, are accounts, whose rules are governed by their validity predicates. Many of the base ledger subsystems specified here are themselves just special Namada accounts too (e.g. PoS, IBC and MASP). This model is broadly similar to that of [Ethereum](https://ethereum.org/en), where each account is associated with contract code, but differs in the execution model.

Interactions with the Namada ledger are made possible via transactions. In Namada, transactions are allowed to perform arbitrary modifications to the storage of any account, but the transaction will be accepted and state changes applied only if all the validity predicates that were triggered by the transaction accept it. That is, the accounts whose storage sub-spaces were touched by the transaction will all have their validity predicates verifying the transaction. A transaction may also explicitly elect an account as the verifier of that transaction, which will result in that validity predicate being invoked as well. A transaction can add any number of additional verifiers, but cannot remove the ones determined by the protocol. For example, a transparent fungible token transfer would typically trigger 3 validity predicates - those of the token, source and target addresses.

The ledger knows what addresses are involved in a WASM transaction because of how the storage is constructed. Each variable in storage is inherently tied to a substorage owned by some account, and thus that VP is invoked.

## Supported validity predicates

While the execution model is fully programmable, for Namada only a selected subset of provided validity predicates and transactions will be permitted through pre-defined whitelists configured at network launch. 

There are some native VPs for internal transparent addresses that are built into the ledger. All the other VPs are implemented as WASM programs. One can build a custom VP using the [VP template](https://github.com/anoma/namada/tree/main/wasm/vp_template) or use one of the pre-defined VPs.

{/* TODO: Make sure this is up to date with the ledger */}
Supported validity predicates for Namada:
- Native
    - Proof-of-stake (see [spec](../modules/proof-of-stake.mdx))
    - Ethereum bridge (see [spec](../modules/ethereum-bridge.mdx))
    - IBC & IbcToken (see [spec](../modules/ibc.mdx))
    - Governance (see [spec](../modules/governance.mdx))
    - Protocol parameters (part of governance)
    - Multitoken (see [spec](../modules/multitoken.mdx))
- WASM
    - MASP (see [spec](../modules/masp.mdx))
    - k-of-n multisignature (see [spec](../modules/multisignature.mdx))

</document_content></document>

<document index="16">
<source>namada-src/namada-docs/packages/specs/pages/index.mdx</source>
<document_content>
import { SpecsAscii } from '../components/SpecsAscii'

# Namada

<br />
<SpecsAscii/>

## What is Namada?

Namada is a sovereign proof-of-stake layer-one blockchain, using the [CometBFT](https://cometbft.com/) (nee Tendermint) BFT consensus algorithm. Namada enables multi-asset shielded transfers for any native or non-native asset using a [multi-asset shielded pool](https://research.metastate.dev/multi-asset_shielded_pool/) derived from the [Sapling circuit](https://z.cash/upgrade/sapling/).

Namada features full IBC protocol support, a natively integrated [Ethereum bridge](./modules/ethereum-bridge.mdx), a modern [proof-of-stake system](./modules/proof-of-stake.mdx) with cubic slashing, a [stake-weighted governance signalling mechanism](./modules/governance.mdx), and a dual continuous/retroactive [public goods funding system](./modules/governance/public-goods-funding.mdx).

Users of the MASP are [rewarded](./modules/masp/shielded-pool-incentives.mdx) for their contributions to the shielded set in the form of native protocol tokens (NAM). 

Namada also supports shielded actions, which allow users to hold their assets shielded on Namada most of the time while occasionally unshielding specific assets in order to interact with existing applications on transparent chains.

You can find an introduction to Namada from a product perspective [here](https://namada.net/blog/introducing-namada-multichain-asset-agnostic-data-protection).

### What is Anoma?

Anoma is an intent-centric architecture for decentralized counterparty discovery, solving, and settlement. You can find the Anoma specs [here](https://specs.anoma.net).

### How does Namada relate to Anoma?

Anoma is a full-stack architecture designed with a long term perspective, while Namada is a specific chain and featureset designed to provide practical data protection now.

### Why Namada?

Data protection should be default and inherent in the systems we use for transacting, yet safe and user-friendly multi-asset data protection doesn't yet exist in the blockchain ecosystem.
Up until now, users have had the choice of either a sovereign chain that reissues assets (e.g. [Zcash](https://z.cash/))
or a data protection solution built on an existing smart contract chain. Both have large trade-offs: in the former case, users don't have assets that they actually want to transact with, and in the latter case, the restrictions of existing platforms mean that users leak non-trivial metadata, and the protocols may be expensive and clunky to use.

Namada supports any fungible or non-fungible asset on an IBC-compatible blockchain
as well as fungible or non-fungible assets sent over a custom Ethereum bridge (such as ERC20 tokens and ERC721 tokens, respectively). Once assets are on Namada, shielded transfers are cheap and all assets contribute to the same shielded set.

Users of Namada earn rewards for shieldiing assets and contributing to shared data protection.

### Layout of this specification

These documents describe the behavior of the Namada protocol. This description is organized into five sub-sections:

1. [Base Ledger](./base-ledger.mdx): This section describes the core ledger functionality of the Namada protocol. This includes the consensus, execution model, fee system, and environment in which modules operate.
2. [Modules](./modules.mdx): This section describes the modules that make up the Namada protocol. Each module is a distinct part of the protocol grouping a related set of features that can be understood in isolation from other modules.

This book is written using [NextraJS](https://nextra.site/). The source can be found in the [Namada Docs repository](https://github.com/anoma/namada-docs/tree/master/packages/specs).

Contributions to the contents and the structure of this book should be made via [pull requests](https://github.com/anoma/namada-docs/pulls).

</document_content></document>

<document index="17">
<source>namada-src/namada-docs/packages/specs/pages/modules.mdx</source>
<document_content>
# Modules

Namada's features are grouped into _modules_. Each module defines:
- a validity predicate, which controls a storage sub-space in the ledger state;
- a set of data structures and a storage layout, which are used in this storage sub-space;
- a set of transactions, which allow users to take actions that change state in this storage sub-space; and, optionally
- handlers to be run on various block lifecycle events (e.g. during ABCI's `FinalizeBlock` or at the end of each epoch), which can be used to implement periodic, automated state changes (e.g. minting new tokens at the end of an epoch and distributing them to delegators)

Namada includes the following modules:

- [Multitoken](./modules/multitoken.mdx)
- [Multisignature](./modules/multisignature.mdx)
- [Proof-of-stake](./modules/proof-of-stake.mdx)
- [Multi-asset-shielded-pool (MASP)](./modules/masp.mdx)
- [Governance](./modules/governance.mdx)
- [IBC](./modules/ibc.mdx)
- [Ethereum bridge](./modules/ethereum-bridge.mdx)
</document_content></document>

<document index="18">
<source>namada-src/namada/documentation/dev/src/SUMMARY.md</source>
<document_content>
# Summary

- [Introduction](./README.md)
- [Exploration](./explore/README.md)
  - [Design](./explore/design/README.md)
    - [Overview](./explore/design/overview.md)
    - [The ledger](./explore/design/ledger.md)
      - [Parameters](./explore/design/ledger/parameters.md)
      - [Epochs](./explore/design/ledger/epochs.md)
      - [Accounts](./explore/design/ledger/accounts.md)
      - [Validity predicates](./explore/design/ledger/vp.md)
      - [Transactions](./explore/design/ledger/tx.md)
      - [WASM VM](./explore/design/ledger/wasm-vm.md)
      - [Front-running prevention](./explore/design/ledger/front-running.md)
      - [Fractal scaling](./explore/design/ledger/fractal-scaling.md)
      - [Upgrade system](./explore/design/upgrade-system.md)
      - [Storage](./explore/design/ledger/storage.md)
        - [Data schema](./explore/design/ledger/storage/data-schema.md)
      - [PoS integration](./explore/design/ledger/pos-integration.md)
      - [IBC integration](./explore/design/ledger/ibc.md)
    - [Crypto primitives](./explore/design/crypto-primitives.md)
    - [Actors](./explore/design/actors.md)
    - [Testnet setup](./explore/design/testnet-setup.md)
    - [Testnet launch procedure](./explore/design/testnet-launch-procedure/README.md)
  - [Dev](./explore/dev/README.md)
    - [Development considerations](./explore/dev/development-considerations.md)
    - [Git](./explore/dev/git.md)
    - [Storage API](./explore/dev/storage_api.md)
    - [Maintenance](./explore/dev/maintenance.md)
  - [Libraries & Tools](./explore/libraries/README.md)
    - [Cryptography]()
    - [network](./explore/libraries/network.md)
    - [Command-line interface](./explore/libraries/cli.md)
    - [Database](./explore/libraries/db.md)
    - [Logging](./explore/libraries/logging.md)
    - [Networking]()
    - [Packaging](./explore/libraries/packaging.md)
    - [Serialization](./explore/libraries/serialization.md)
    - [WASM runtime](./explore/libraries/wasm.md)
    - [Error handling](./explore/libraries/errors.md)
  - [Glossary](./explore/design/glossary.md)
  - [Resources](./explore/resources/README.md)
    - [IDE](./explore/resources/ide.md)
- [Specifications](./specs/README.md)
  - [Overview](./specs/overview.md)
  - [The ledger](./specs/ledger.md)
    - [RPC](./specs/ledger/rpc.md)
    - [Default transactions](./specs/ledger/default-transactions.md)
    - [Default validity predicates](./specs/ledger/default-validity-predicates.md)
  - [Trade system]()
  - [Intent gossip system]()
  - [Fractal scaling]()
  - [Upgrade system]()
  - [Crypto](./specs/crypto.md)
  - [Encoding](./specs/encoding.md)
- [Archive](./archive/README.md)
  - [Domain name addresses](./archive/domain-name-addresses.md)

</document_content></document>


</documents>
<cli>namada --help

Namada command line interface.

Usage: namada [OPTIONS] <COMMAND>

Commands:
  node                  Node sub-commands.
  relayer               Relayer sub-commands.
  client                Client sub-commands.
  wallet                Wallet sub-commands.
  ethereum-bridge-pool  Functionality for interacting with the Ethereum bridge pool. This pool holds transfers waiting to be relayed to Ethereum.
  ledger                Ledger node sub-commands. If no sub-command specified, defaults to run the node.
  tx                    Send a transaction with custom WASM code.
  transfer              Send a signed transfer transaction.
  ibc-transfer          Send a signed IBC transfer transaction.
  update-account        Send a signed transaction to update account's validity predicate.
  init-proposal         Create a new proposal.
  vote-proposal         Vote a proposal.
  reveal-pk             Submit a tx to reveal the public key an implicit account. Typically, you don't have to do this manually and the client will detect when a tx to reveal PK is needed and submit it automatically. This will write the PK into the account's storage so that it can be used for signature verification on transactions authorized by this account.
  help                  Print this message or the help of the given subcommand(s)

Options:
      --chain-id <chain-id>  The chain ID.
      --base-dir <base-dir>  The base directory is where the nodes, client and wallet configuration and state is stored. This value can also be set via `NAMADA_BASE_DIR` environment variable, but the argument takes precedence, if specified. Defaults to `$XDG_DATA_HOME/namada` (`$HOME/.local/share/namada` where `XDG_DATA_HOME` is unset) on Unix,`$HOME/Library/Application Support/Namada` on Mac,and `%AppData%\Namada` on Windows.
      --wasm-dir <wasm-dir>  Directory with built WASM validity predicates, transactions. This value can also be set via `NAMADA_WASM_DIR` environment variable, but the argument takes precedence, if specified.
      --pre-genesis          Dispatch pre-genesis specific logic.
  -h, --help                 Print help
  -V, --version              Print version
</cli>

<cli>namada relayer --help

Relayer sub-commands.

Usage: namada relayer [OPTIONS] <COMMAND>

Commands:
  ethereum-bridge-pool  Functionality for interacting with the Ethereum bridge pool. This pool holds transfers waiting to be relayed to Ethereum.
  validator-set         Validator set queries, that return data in a format to be consumed by the Namada Ethereum bridge smart contracts.
  help                  Print this message or the help of the given subcommand(s)

Options:
      --chain-id <chain-id>  The chain ID.
      --base-dir <base-dir>  The base directory is where the nodes, client and wallet configuration and state is stored. This value can also be set via `NAMADA_BASE_DIR` environment variable, but the argument takes precedence, if specified. Defaults to `$XDG_DATA_HOME/namada` (`$HOME/.local/share/namada` where `XDG_DATA_HOME` is unset) on Unix,`$HOME/Library/Application Support/Namada` on Mac,and `%AppData%\Namada` on Windows.
      --wasm-dir <wasm-dir>  Directory with built WASM validity predicates, transactions. This value can also be set via `NAMADA_WASM_DIR` environment variable, but the argument takes precedence, if specified.
      --pre-genesis          Dispatch pre-genesis specific logic.
  -h, --help                 Print help
</cli>

<cli>namada relayer validator-set governance --help

Query the Governance validator set in Namada, at the given epoch, or the latest one, if none is provided.

Usage: namada relayer validator-set governance [OPTIONS]

Options:
      --chain-id <chain-id>  The chain ID.
      --node <node>          Address of a ledger node as "{scheme}://{host}:{port}". If the scheme is not supplied, it is assumed to be TCP.
      --base-dir <base-dir>  The base directory is where the nodes, client and wallet configuration and state is stored. This value can also be set via `NAMADA_BASE_DIR` environment variable, but the argument takes precedence, if specified. Defaults to `$XDG_DATA_HOME/namada` (`$HOME/.local/share/namada` where `XDG_DATA_HOME` is unset) on Unix,`$HOME/Library/Application Support/Namada` on Mac,and `%AppData%\Namada` on Windows.
      --epoch <epoch>        The epoch of the Governance set of validators to query.
      --wasm-dir <wasm-dir>  Directory with built WASM validity predicates, transactions. This value can also be set via `NAMADA_WASM_DIR` environment variable, but the argument takes precedence, if specified.
      --pre-genesis          Dispatch pre-genesis specific logic.
  -h, --help                 Print help
</cli>

<cli>namada relayer validator-set proof --help

Query an Ethereum ABI encoding of a proof of the consensus validator set in Namada, at the requested epoch, or the next one, if no epoch is provided.

Usage: namada relayer validator-set proof [OPTIONS]

Options:
      --chain-id <chain-id>  The chain ID.
      --node <node>          Address of a ledger node as "{scheme}://{host}:{port}". If the scheme is not supplied, it is assumed to be TCP.
      --base-dir <base-dir>  The base directory is where the nodes, client and wallet configuration and state is stored. This value can also be set via `NAMADA_BASE_DIR` environment variable, but the argument takes precedence, if specified. Defaults to `$XDG_DATA_HOME/namada` (`$HOME/.local/share/namada` where `XDG_DATA_HOME` is unset) on Unix,`$HOME/Library/Application Support/Namada` on Mac,and `%AppData%\Namada` on Windows.
      --epoch <epoch>        The epoch of the set of validators to be proven.
      --wasm-dir <wasm-dir>  Directory with built WASM validity predicates, transactions. This value can also be set via `NAMADA_WASM_DIR` environment variable, but the argument takes precedence, if specified.
      --pre-genesis          Dispatch pre-genesis specific logic.
  -h, --help                 Print help
</cli>

<cli>namada relayer validator-set relay --help

Relay a validator set update to Namada's Ethereum bridge smart contracts.

Usage: namada relayer validator-set relay [OPTIONS] --confirmations <confirmations>

Options:
      --chain-id <chain-id>
          The chain ID.
      --node <node>
          Address of a ledger node as "{scheme}://{host}:{port}". If the scheme is not supplied, it is assumed to be TCP.
      --base-dir <base-dir>
          The base directory is where the nodes, client and wallet configuration and state is stored. This value can also be set via `NAMADA_BASE_DIR` environment variable, but the argument takes precedence, if specified. Defaults to `$XDG_DATA_HOME/namada` (`$HOME/.local/share/namada` where `XDG_DATA_HOME` is unset) on Unix,`$HOME/Library/Application Support/Namada` on Mac,and `%AppData%\Namada` on Windows.
      --safe-mode
          Safe mode overrides keyboard interrupt signals, to ensure Ethereum transfers aren't canceled midway through.
      --daemon
          Run in daemon mode, which will continuously perform validator set updates.
      --wasm-dir <wasm-dir>
          Directory with built WASM validity predicates, transactions. This value can also be set via `NAMADA_WASM_DIR` environment variable, but the argument takes precedence, if specified.
      --pre-genesis
          Dispatch pre-genesis specific logic.
      --retry-sleep <retry-sleep>
          The amount of time to sleep between failed daemon mode relays.
      --success-sleep <success-sleep>
          The amount of time to sleep between successful daemon mode relays.
      --ethereum-address <ethereum-address>
          The address of the Ethereum wallet to pay the gas fees. If unset, the default wallet is used.
      --epoch <epoch>
          The epoch of the set of validators to relay.
      --eth-gas <eth-gas>
          The Ethereum gas that can be spent during the relay call.
      --eth-gas-price <eth-gas-price>
          The price of Ethereum gas, during the relay call.
      --eth-rpc-endpoint <eth-rpc-endpoint>
          The Ethereum RPC endpoint.
      --confirmations <confirmations>
          The number of block confirmations on Ethereum.
      --sync
          Synchronize with the network, or exit immediately, if the Ethereum node has fallen behind.
  -h, --help
          Print help
</cli>

<cli>namada ethereum-bridge-pool relay-proof --help

Construct a merkle proof that the given transfers are in the pool and relay it to Ethereum.

Usage: namada ethereum-bridge-pool relay-proof [OPTIONS] --hash-list <hash-list> --relayer <relayer> --confirmations <confirmations>

Options:
      --chain-id <chain-id>
          The chain ID.
      --node <node>
          Address of a ledger node as "{scheme}://{host}:{port}". If the scheme is not supplied, it is assumed to be TCP.
      --base-dir <base-dir>
          The base directory is where the nodes, client and wallet configuration and state is stored. This value can also be set via `NAMADA_BASE_DIR` environment variable, but the argument takes precedence, if specified. Defaults to `$XDG_DATA_HOME/namada` (`$HOME/.local/share/namada` where `XDG_DATA_HOME` is unset) on Unix,`$HOME/Library/Application Support/Namada` on Mac,and `%AppData%\Namada` on Windows.
      --safe-mode
          Safe mode overrides keyboard interrupt signals, to ensure Ethereum transfers aren't canceled midway through.
      --hash-list <hash-list>
          Whitespace separated Keccak hash list of transfers in the Bridge pool.
      --wasm-dir <wasm-dir>
          Directory with built WASM validity predicates, transactions. This value can also be set via `NAMADA_WASM_DIR` environment variable, but the argument takes precedence, if specified.
      --pre-genesis
          Dispatch pre-genesis specific logic.
      --relayer <relayer>
          The rewards address for relaying this proof.
      --ethereum-address <ethereum-address>
          The address of the Ethereum wallet to pay the gas fees. If unset, the default wallet is used.
      --eth-gas <eth-gas>
          The Ethereum gas that can be spent during the relay call.
      --eth-gas-price <eth-gas-price>
          The price of Ethereum gas, during the relay call.
      --eth-rpc-endpoint <eth-rpc-endpoint>
          The Ethereum RPC endpoint.
      --confirmations <confirmations>
          The number of block confirmations on Ethereum.
      --sync
          Synchronize with the network, or exit immediately, if the Ethereum node has fallen behind.
  -h, --help
          Print help
</cli>

<cli>osmosisd query --help

Querying subcommands

Usage:
  osmosisd query [flags]
  osmosisd query [command]

Aliases:
  query, q

Available Commands:
  account                  Query for account by address
  auth                     Querying commands for the auth module
  authz                    Querying commands for the authz module
  bank                     Querying commands for the bank module
  block                    Get verified data for the block at given height
  concentratedliquidity    Querying commands for the concentratedliquidity module
  cosmwasmpool             Querying commands for the cosmwasmpool module
  distribution             Querying commands for the distribution module
  downtimedetector         Querying commands for the downtimedetector module
  epochs                   Querying commands for the epochs module
  evidence                 Query for evidence by hash or for all (paginated) submitted evidence
  gamm                     Querying commands for the gamm module
  gov                      Querying commands for the governance module
  ibc                      Querying commands for the IBC module
  ibc-transfer             IBC fungible token transfer query subcommands
  ibchooks                 Querying commands for the ibchooks module
  incentives               Querying commands for the incentives module
  interchain-accounts      IBC interchain accounts query subcommands
  interchainquery          Querying commands for the interchainquery module
  lockup                   Querying commands for the lockup module
  mint                     Querying commands for the mint module
  packetforward            Querying commands for the packetforward module
  params                   Querying commands for the params module
  poolincentives           Querying commands for the poolincentives module
  poolmanager              Querying commands for the poolmanager module
  protorev                 Querying commands for the protorev module
  rate-limited-ibc         Querying commands for the rate-limited-ibc module
  slashing                 Querying commands for the slashing module
  staking                  Querying commands for the staking module
  superfluid               Querying commands for the superfluid module
  tendermint-validator-set Get the full tendermint validator set at given height
  tokenfactory             Querying commands for the tokenfactory module
  twap                     Querying commands for the twap module
  tx                       Query for a transaction by hash, "<addr>/<seq>" combination or comma-separated signatures in a committed block
  txfees                   Querying commands for the txfees module
  txs                      Query for paginated transactions that match a set of events
  upgrade                  Querying commands for the upgrade module
  valsetpref               Querying commands for the valsetpref module
  wasm                     Querying commands for the wasm module

Flags:
      --chain-id string   The network chain ID
  -h, --help              help for query

Global Flags:
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "osmosisd query [command] --help" for more information about a command.
</cli>

<cli>osmosisd query auth --help

Querying commands for the auth module

Usage:
  osmosisd query auth [flags]
  osmosisd query auth [command]

Available Commands:
  account            Query for account by address
  accounts           Query all the accounts
  address-by-acc-num Query for an address by account number
  module-account     Query module account info by module name
  module-accounts    Query all module accounts
  params             Query the current auth parameters

Flags:
  -h, --help   help for auth

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "osmosisd query auth [command] --help" for more information about a command.
</cli>

<cli>osmosisd query authz --help

Querying commands for the authz module

Usage:
  osmosisd query authz [flags]
  osmosisd query authz [command]

Available Commands:
  grants            query grants for a granter-grantee pair and optionally a msg-type-url
  grants-by-grantee query authorization grants granted to a grantee
  grants-by-granter query authorization grants granted by granter

Flags:
  -h, --help   help for authz

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "osmosisd query authz [command] --help" for more information about a command.
</cli>

<cli>osmosisd query gamm --help

Querying commands for the gamm module

Usage:
  osmosisd query gamm [command]
  
Available Commands:
  cfmm-cl-pool-links             Query all concentrated pool and cfmm pool id links
  cl-pool-link-from-cfmm         Query concentrated pool id link from cfmm pool id
  estimate-swap-exact-amount-in  Query estimate-swap-exact-amount-in
  estimate-swap-exact-amount-out Query estimate-swap-exact-amount-out
  num-pools                      Query number of pools
  pool                           Query pool
  pool-params                    Query pool-params
  pool-type                      Query pool type
  pools                          Query pools
  pools-with-filter              Query pools with filter
  spot-price                     Query spot-price (LEGACY, arguments are reversed!!)
  total-liquidity                Query total-liquidity
  total-pool-liquidity           Query total-pool-liquidity
  total-share                    Query total-share

Use "osmosisd query gamm [command] --help" for more information about a command.
</cli>

<cli>osmosisd query gamm cfmm-cl-pool-links --help

Query all concentrated pool and cfmm pool id links

Example:
$ osmosisd q gamm cfmm-cl-pool-links

Usage:
  osmosisd query gamm cfmm-cl-pool-links [flags]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for cfmm-cl-pool-links
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc --help

Querying commands for the IBC module

Usage:
  osmosisd query ibc [flags]
  osmosisd query ibc [command]

Available Commands:
  channel     IBC channel query subcommands
  client      IBC client query subcommands
  connection  IBC connection query subcommands

Flags:
  -h, --help   help for ibc

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "osmosisd query ibc [command] --help" for more information about a command.
</cli>

<cli>osmosisd query ibc channel --help

IBC channel query subcommands

Usage:
  osmosisd query ibc channel [flags]
  osmosisd query ibc channel [command]

Available Commands:
  channels              Query all channels
  client-state          Query the client state associated with a channel
  connections           Query all channels associated with a connection
  end                   Query a channel end
  next-sequence-receive Query a next receive sequence
  packet-ack            Query a packet acknowledgement
  packet-commitment     Query a packet commitment
  packet-commitments    Query all packet commitments associated with a channel
  packet-receipt        Query a packet receipt
  unreceived-acks       Query all the unreceived acks associated with a channel
  unreceived-packets    Query all the unreceived packets associated with a channel

Flags:
  -h, --help   help for channel

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "osmosisd query ibc channel [command] --help" for more information about a command.
</cli>

<cli>osmosisd query ibc channel channels --help

Query all channels from a chain

Usage:
  osmosisd query ibc channel channels [flags]

Examples:
osmosisd query ibc channel channels

Flags:
      --count-total        count total number of records in channels to query for
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for channels
      --limit uint         pagination limit of channels to query for (default 100)
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint        pagination offset of channels to query for
  -o, --output string      Output format (text|json) (default "text")
      --page uint          pagination page of channels to query for. This sets offset to a multiple of limit (default 1)
      --page-key string    pagination page-key of channels to query for
      --reverse            results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc channel client-state --help

Query the client state associated with a channel, by providing its port and channel identifiers.

Usage:
  osmosisd query ibc channel client-state [port-id] [channel-id] [flags]

Examples:
osmosisd query ibc channel client-state [port-id] [channel-id]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for client-state
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc channel connections --help

Query all channels associated with a connection

Usage:
  osmosisd query ibc channel connections [connection-id] [flags]

Examples:
osmosisd query ibc channel connections [connection-id]

Flags:
      --count-total        count total number of records in channels associated with a connection to query for
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for connections
      --limit uint         pagination limit of channels associated with a connection to query for (default 100)
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint        pagination offset of channels associated with a connection to query for
  -o, --output string      Output format (text|json) (default "text")
      --page uint          pagination page of channels associated with a connection to query for. This sets offset to a multiple of limit (default 1)
      --page-key string    pagination page-key of channels associated with a connection to query for
      --reverse            results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc channel end --help

Query an IBC channel end from a port and channel identifiers

Usage:
  osmosisd query ibc channel end [port-id] [channel-id] [flags]

Examples:
osmosisd query ibc channel end [port-id] [channel-id]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for end
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")
      --prove              show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc channel next-sequence-receive --help

Query the next receive sequence for a given channel

Usage:
  osmosisd query ibc channel next-sequence-receive [port-id] [channel-id] [flags]

Examples:
osmosisd query ibc channel next-sequence-receive [port-id] [channel-id]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for next-sequence-receive
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")
      --prove              show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc channel packet-ack --help

Query a packet acknowledgement

Usage:
  osmosisd query ibc channel packet-ack [port-id] [channel-id] [sequence] [flags]

Examples:
osmosisd query ibc channel packet-ack [port-id] [channel-id] [sequence]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for packet-ack
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")
      --prove              show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc channel packet-commitment --help

Query a packet commitment

Usage:
  osmosisd query ibc channel packet-commitment [port-id] [channel-id] [sequence] [flags]

Examples:
osmosisd query ibc channel packet-commitment [port-id] [channel-id] [sequence]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for packet-commitment
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")
      --prove              show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc channel packet-commitments --help

Query all packet commitments associated with a channel

Usage:
  osmosisd query ibc channel packet-commitments [port-id] [channel-id] [flags]

Examples:
osmosisd query ibc channel packet-commitments [port-id] [channel-id]

Flags:
      --count-total        count total number of records in packet commitments associated with a channel to query for
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for packet-commitments
      --limit uint         pagination limit of packet commitments associated with a channel to query for (default 100)
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint        pagination offset of packet commitments associated with a channel to query for
  -o, --output string      Output format (text|json) (default "text")
      --page uint          pagination page of packet commitments associated with a channel to query for. This sets offset to a multiple of limit (default 1)
      --page-key string    pagination page-key of packet commitments associated with a channel to query for
      --reverse            results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc channel packet-receipt --help

Query a packet receipt

Usage:
  osmosisd query ibc channel packet-receipt [port-id] [channel-id] [sequence] [flags]

Examples:
osmosisd query ibc channel packet-receipt [port-id] [channel-id] [sequence]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for packet-receipt
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")
      --prove              show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc channel unreceived-acks --help

Given a list of acknowledgement sequences from counterparty, determine if an ack on the counterparty chain has been received on the executing chain.

The return value represents:
- Unreceived packet acknowledgement: packet commitment exists on original sending (executing) chain and ack exists on receiving chain.

Usage:
  osmosisd query ibc channel unreceived-acks [port-id] [channel-id] [flags]

Examples:
osmosisd query ibc channel unreceived-acks [port-id] [channel-id] --sequences=1,2,3

Flags:
      --grpc-addr string       the gRPC endpoint to use for this chain
      --grpc-insecure          allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int             Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help                   help for unreceived-acks
      --node string            <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string          Output format (text|json) (default "text")
      --sequences int64Slice   comma separated list of packet sequence numbers (default [])

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc channel unreceived-packets --help

Determine if a packet, given a list of packet commitment sequences, is unreceived.

The return value represents:
- Unreceived packet commitments: no acknowledgement exists on receiving chain for the given packet commitment sequence on sending chain.

Usage:
  osmosisd query ibc channel unreceived-packets [port-id] [channel-id] [flags]

Examples:
osmosisd query ibc channel unreceived-packets [port-id] [channel-id] --sequences=1,2,3

Flags:
      --grpc-addr string       the gRPC endpoint to use for this chain
      --grpc-insecure          allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int             Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help                   help for unreceived-packets
      --node string            <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string          Output format (text|json) (default "text")
      --sequences int64Slice   comma separated list of packet sequence numbers (default [])

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query ibc client --help

IBC client query subcommands

Usage:
  osmosisd query ibc client [flags]
  osmosisd query ibc client [command]

Available Commands:
  consensus-state         Query the consensus state of a client at a given height
  consensus-state-heights Query the heights of all consensus states of a client.
  consensus-states        Query all the consensus states of a client.
  header                  Query the latest header of the running chain
  params                  Query the current ibc client parameters
  self-consensus-state    Query the self consensus state for this chain
  state                   Query a client state
  states                  Query all available light clients
  status                  Query client status

Flags:
  -h, --help   help for client

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "osmosisd query ibc client [command] --help" for more information about a command.
</cli>


<cli>osmosisd query superfluid --help

Querying commands for the superfluid module

Usage:
  osmosisd query superfluid [command]
  
Available Commands:
  all-intermediary-accounts            Query all superfluid intermediary accounts
  all-superfluid-assets                Query all superfluid assets
  asset-multiplier                     Query asset multiplier by denom
  connected-intermediary-account       Query connected intermediary account
  params                               Query the current superfluid parameters
  superfluid-delegation-amount         Query coins superfluid delegated for a delegator, validator, denom
  superfluid-delegation-by-delegator   Query coins superfluid delegated for the specified delegator
  superfluid-undelegation-by-delegator Query coins superfluid undelegated for the specified delegator
  total-delegation-by-delegator        Query both superfluid delegation and normal delegation
  total-superfluid-delegations         Query total amount of osmo delegated via superfluid staking
  unpool-whitelist                     Query whitelisted pool ids to unpool

Use "osmosisd query superfluid [command] --help" for more information about a command.
</cli>

<cli>osmosisd query superfluid all-intermediary-accounts --help

Query all superfluid intermediary accounts

Usage:
  osmosisd query superfluid all-intermediary-accounts [flags]

Flags:
      --count-total        count total number of records in all-intermediary-accounts to query for
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for all-intermediary-accounts
      --limit uint         pagination limit of all-intermediary-accounts to query for (default 100)
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint        pagination offset of all-intermediary-accounts to query for
  -o, --output string      Output format (text|json) (default "text")
      --page uint          pagination page of all-intermediary-accounts to query for. This sets offset to a multiple of limit (default 1)
      --page-key string    pagination page-key of all-intermediary-accounts to query for
      --reverse            results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query superfluid all-superfluid-assets --help

Query all superfluid assets

Usage:
  osmosisd query superfluid all-superfluid-assets [flags]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for all-superfluid-assets
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query superfluid asset-multiplier --help

Query asset multiplier by denom

Example:
$ osmosisd q superfluid asset-multiplier gamm/pool/1

Usage:
  osmosisd query superfluid asset-multiplier [denom] [flags]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for asset-multiplier
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query superfluid connected-intermediary-account --help

Query connected intermediary account

Example:
$ osmosisd q superfluid connected-intermediary-account 1

Usage:
  osmosisd query superfluid connected-intermediary-account [lock-id] [flags]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for connected-intermediary-account
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query superfluid params --help

Query parameters for the superfluid module:

$ <appd> query superfluid params

Usage:
  osmosisd query superfluid params [flags]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for params
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query superfluid superfluid-delegation-amount --help

Query coins superfluid delegated for a delegator, validator, denom

Usage:
  osmosisd query superfluid superfluid-delegation-amount [delegator-address] [validator-address] [denom] [flags]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for superfluid-delegation-amount
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query superfluid superfluid-delegation-by-delegator --help

Query coins superfluid delegated for the specified delegator

Usage:
  osmosisd query superfluid superfluid-delegation-by-delegator [delegator-address] [validator-address] [denom] [flags]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for superfluid-delegation-by-delegator
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query superfluid superfluid-undelegation-by-delegator --help

Query coins superfluid undelegated for the specified delegator

Usage:
  osmosisd query superfluid superfluid-undelegation-by-delegator [delegator-address] [denom] [flags]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for superfluid-undelegation-by-delegator
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query superfluid total-delegation-by-delegator --help

Query both superfluid delegation and normal delegation

Usage:
  osmosisd query superfluid total-delegation-by-delegator [delegator-address] [flags]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for total-delegation-by-delegator
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query superfluid total-superfluid-delegations --help

Query total amount of osmo delegated via superfluid staking

Usage:
  osmosisd query superfluid total-superfluid-delegations [flags]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for total-superfluid-delegations
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd query superfluid unpool-whitelist --help

Query whitelisted pool ids to unpool

Usage:
  osmosisd query superfluid unpool-whitelist [flags]

Flags:
      --grpc-addr string   the gRPC endpoint to use for this chain
      --grpc-insecure      allow gRPC over insecure channels, if not TLS the server must use TLS
      --height int         Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help               help for unpool-whitelist
      --node string        <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string      Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>


<cli>osmosisd tx ibc --help

IBC transaction subcommands

Usage:
  osmosisd tx ibc [flags]
  osmosisd tx ibc [command]

Available Commands:
  channel     IBC channel transaction subcommands
  client      IBC client transaction subcommands

Flags:
  -h, --help   help for ibc

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "osmosisd tx ibc [command] --help" for more information about a command.
</cli>

<cli>osmosisd tx ibc channel --help

IBC channel transaction subcommands

Usage:
  osmosisd tx ibc channel [flags]

Flags:
  -h, --help   help for channel

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd tx ibc client --help

IBC client transaction subcommands

Usage:
  osmosisd tx ibc client [flags]
  osmosisd tx ibc client [command]

Available Commands:
  create       create new IBC client
  misbehaviour submit a client misbehaviour
  update       update existing client with a client message
  upgrade      upgrade an IBC client

Flags:
  -h, --help   help for client

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "osmosisd tx ibc client [command] --help" for more information about a command.
</cli>

<cli>osmosisd tx ibc client create --help

create a new IBC client with the specified client state and consensus state
	- ClientState JSON example: {"@type":"/ibc.lightclients.solomachine.v1.ClientState","sequence":"1","frozen_sequence":"0","consensus_state":{"public_key":{"@type":"/cosmos.crypto.secp256k1.PubKey","key":"AtK50+5pJOoaa04qqAqrnyAqsYrwrR/INnA6UPIaYZlp"},"diversifier":"testing","timestamp":"10"},"allow_update_after_proposal":false}
	- ConsensusState JSON example: {"@type":"/ibc.lightclients.solomachine.v1.ConsensusState","public_key":{"@type":"/cosmos.crypto.secp256k1.PubKey","key":"AtK50+5pJOoaa04qqAqrnyAqsYrwrR/INnA6UPIaYZlp"},"diversifier":"testing","timestamp":"10"}

Usage:
  osmosisd tx ibc client create [path/to/client_state.json] [path/to/consensus_state.json] [flags]

Examples:
osmosisd tx ibc client create [path/to/client_state.json] [path/to/consensus_state.json] --from node0 --home ../node0/<app>cli --chain-id $CID

Flags:
  -a, --account-number uint      The account number of the signing account (offline mode only)
      --aux                      Generate aux signer data instead of sending a tx
  -b, --broadcast-mode string    Transaction broadcasting mode (sync|async) (default "sync")
      --chain-id string          The network chain ID
      --dry-run                  ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it (when enabled, the local Keybase is not accessible)
      --fee-granter string       Fee granter grants fees for the transaction
      --fee-payer string         Fee payer pays fees for the transaction instead of deducting from the signer
      --fees string              Fees to pay along with transaction; eg: 10uatom
      --from string              Name or address of private key with which to sign
      --gas string               gas limit to set per-transaction; set to "auto" to calculate sufficient gas automatically. Note: "auto" option doesn't always report accurate results. Set a valid coin value to adjust the result. Can be used instead of "fees". (default 200000)
      --gas-adjustment float     adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored  (default 1)
      --gas-prices string        Gas prices in decimal format to determine the transaction fee (e.g. 0.1uatom)
      --generate-only            Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase only accessed when providing a key name)
  -h, --help                     help for create
      --keyring-backend string   Select keyring's backend (os|file|kwallet|pass|test|memory) (default "os")
      --keyring-dir string       The client Keyring directory; if omitted, the default 'home' directory will be used
      --ledger                   Use a connected Ledger device
      --node string              <host>:<port> to tendermint rpc interface for this chain (default "tcp://localhost:26657")
      --note string              Note to add a description to the transaction (previously --memo)
      --offline                  Offline mode (does not allow any online functionality)
  -o, --output string            Output format (text|json) (default "json")
  -s, --sequence uint            The sequence number of the signing account (offline mode only)
      --sign-mode string         Choose sign mode (direct|amino-json|direct-aux), this is an advanced feature
      --timeout-height uint      Set a block timeout height to prevent the tx from being committed past a certain height
      --tip string               Tip is the amount that is going to be transferred to the fee payer on the target chain. This flag is only valid when used with --aux, and is ignored if the target chain didn't enable the TipDecorator
  -y, --yes                      Skip tx broadcasting prompt confirmation

Global Flags:
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd tx ibc client misbehaviour --help

submit a client misbehaviour to prevent future updates

Usage:
  osmosisd tx ibc client misbehaviour [clientID] [path/to/misbehaviour.json] [flags]

Examples:
osmosisd tx ibc client misbehaviour [clientID] [path/to/misbehaviour.json] --from node0 --home ../node0/<app>cli --chain-id $CID

Flags:
  -a, --account-number uint      The account number of the signing account (offline mode only)
      --aux                      Generate aux signer data instead of sending a tx
  -b, --broadcast-mode string    Transaction broadcasting mode (sync|async) (default "sync")
      --chain-id string          The network chain ID
      --dry-run                  ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it (when enabled, the local Keybase is not accessible)
      --fee-granter string       Fee granter grants fees for the transaction
      --fee-payer string         Fee payer pays fees for the transaction instead of deducting from the signer
      --fees string              Fees to pay along with transaction; eg: 10uatom
      --from string              Name or address of private key with which to sign
      --gas string               gas limit to set per-transaction; set to "auto" to calculate sufficient gas automatically. Note: "auto" option doesn't always report accurate results. Set a valid coin value to adjust the result. Can be used instead of "fees". (default 200000)
      --gas-adjustment float     adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored  (default 1)
      --gas-prices string        Gas prices in decimal format to determine the transaction fee (e.g. 0.1uatom)
      --generate-only            Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase only accessed when providing a key name)
  -h, --help                     help for misbehaviour
      --keyring-backend string   Select keyring's backend (os|file|kwallet|pass|test|memory) (default "os")
      --keyring-dir string       The client Keyring directory; if omitted, the default 'home' directory will be used
      --ledger                   Use a connected Ledger device
      --node string              <host>:<port> to tendermint rpc interface for this chain (default "tcp://localhost:26657")
      --note string              Note to add a description to the transaction (previously --memo)
      --offline                  Offline mode (does not allow any online functionality)
  -o, --output string            Output format (text|json) (default "json")
  -s, --sequence uint            The sequence number of the signing account (offline mode only)
      --sign-mode string         Choose sign mode (direct|amino-json|direct-aux), this is an advanced feature
      --timeout-height uint      Set a block timeout height to prevent the tx from being committed past a certain height
      --tip string               Tip is the amount that is going to be transferred to the fee payer on the target chain. This flag is only valid when used with --aux, and is ignored if the target chain didn't enable the TipDecorator
  -y, --yes                      Skip tx broadcasting prompt confirmation

Global Flags:
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd tx ibc client update --help

update existing client with a client message, for example a header, misbehaviour or batch update

Usage:
  osmosisd tx ibc client update [client-id] [path/to/client_msg.json] [flags]

Examples:
osmosisd tx ibc client update [client-id] [path/to/client_msg.json] --from node0 --home ../node0/<app>cli --chain-id $CID

Flags:
  -a, --account-number uint      The account number of the signing account (offline mode only)
      --aux                      Generate aux signer data instead of sending a tx
  -b, --broadcast-mode string    Transaction broadcasting mode (sync|async) (default "sync")
      --chain-id string          The network chain ID
      --dry-run                  ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it (when enabled, the local Keybase is not accessible)
      --fee-granter string       Fee granter grants fees for the transaction
      --fee-payer string         Fee payer pays fees for the transaction instead of deducting from the signer
      --fees string              Fees to pay along with transaction; eg: 10uatom
      --from string              Name or address of private key with which to sign
      --gas string               gas limit to set per-transaction; set to "auto" to calculate sufficient gas automatically. Note: "auto" option doesn't always report accurate results. Set a valid coin value to adjust the result. Can be used instead of "fees". (default 200000)
      --gas-adjustment float     adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored  (default 1)
      --gas-prices string        Gas prices in decimal format to determine the transaction fee (e.g. 0.1uatom)
      --generate-only            Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase only accessed when providing a key name)
  -h, --help                     help for update
      --keyring-backend string   Select keyring's backend (os|file|kwallet|pass|test|memory) (default "os")
      --keyring-dir string       The client Keyring directory; if omitted, the default 'home' directory will be used
      --ledger                   Use a connected Ledger device
      --node string              <host>:<port> to tendermint rpc interface for this chain (default "tcp://localhost:26657")
      --note string              Note to add a description to the transaction (previously --memo)
      --offline                  Offline mode (does not allow any online functionality)
  -o, --output string            Output format (text|json) (default "json")
  -s, --sequence uint            The sequence number of the signing account (offline mode only)
      --sign-mode string         Choose sign mode (direct|amino-json|direct-aux), this is an advanced feature
      --timeout-height uint      Set a block timeout height to prevent the tx from being committed past a certain height
      --tip string               Tip is the amount that is going to be transferred to the fee payer on the target chain. This flag is only valid when used with --aux, and is ignored if the target chain didn't enable the TipDecorator
  -y, --yes                      Skip tx broadcasting prompt confirmation

Global Flags:
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd tx ibc client upgrade --help

upgrade the IBC client associated with the provided client identifier while providing proof committed by the counterparty chain to the new client and consensus states
	- ClientState JSON example: {"@type":"/ibc.lightclients.solomachine.v1.ClientState","sequence":"1","frozen_sequence":"0","consensus_state":{"public_key":{"@type":"/cosmos.crypto.secp256k1.PubKey","key":"AtK50+5pJOoaa04qqAqrnyAqsYrwrR/INnA6UPIaYZlp"},"diversifier":"testing","timestamp":"10"},"allow_update_after_proposal":false}
	- ConsensusState JSON example: {"@type":"/ibc.lightclients.solomachine.v1.ConsensusState","public_key":{"@type":"/cosmos.crypto.secp256k1.PubKey","key":"AtK50+5pJOoaa04qqAqrnyAqsYrwrR/INnA6UPIaYZlp"},"diversifier":"testing","timestamp":"10"}

Usage:
  osmosisd tx ibc client upgrade [client-identifier] [path/to/client_state.json] [path/to/consensus_state.json] [upgrade-client-proof] [upgrade-consensus-state-proof] [flags]

Examples:
osmosisd tx ibc client upgrade [client-identifier] [path/to/client_state.json] [path/to/consensus_state.json] [client-state-proof] [consensus-state-proof] --from node0 --home ../node0/<app>cli --chain-id $CID

Flags:
  -a, --account-number uint      The account number of the signing account (offline mode only)
      --aux                      Generate aux signer data instead of sending a tx
  -b, --broadcast-mode string    Transaction broadcasting mode (sync|async) (default "sync")
      --chain-id string          The network chain ID
      --dry-run                  ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it (when enabled, the local Keybase is not accessible)
      --fee-granter string       Fee granter grants fees for the transaction
      --fee-payer string         Fee payer pays fees for the transaction instead of deducting from the signer
      --fees string              Fees to pay along with transaction; eg: 10uatom
      --from string              Name or address of private key with which to sign
      --gas string               gas limit to set per-transaction; set to "auto" to calculate sufficient gas automatically. Note: "auto" option doesn't always report accurate results. Set a valid coin value to adjust the result. Can be used instead of "fees". (default 200000)
      --gas-adjustment float     adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored  (default 1)
      --gas-prices string        Gas prices in decimal format to determine the transaction fee (e.g. 0.1uatom)
      --generate-only            Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase only accessed when providing a key name)
  -h, --help                     help for upgrade
      --keyring-backend string   Select keyring's backend (os|file|kwallet|pass|test|memory) (default "os")
      --keyring-dir string       The client Keyring directory; if omitted, the default 'home' directory will be used
      --ledger                   Use a connected Ledger device
      --node string              <host>:<port> to tendermint rpc interface for this chain (default "tcp://localhost:26657")
      --note string              Note to add a description to the transaction (previously --memo)
      --offline                  Offline mode (does not allow any online functionality)
  -o, --output string            Output format (text|json) (default "json")
  -s, --sequence uint            The sequence number of the signing account (offline mode only)
      --sign-mode string         Choose sign mode (direct|amino-json|direct-aux), this is an advanced feature
      --timeout-height uint      Set a block timeout height to prevent the tx from being committed past a certain height
      --tip string               Tip is the amount that is going to be transferred to the fee payer on the target chain. This flag is only valid when used with --aux, and is ignored if the target chain didn't enable the TipDecorator
  -y, --yes                      Skip tx broadcasting prompt confirmation

Global Flags:
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>osmosisd tx ibc-transfer --help

IBC fungible token transfer transaction subcommands

Usage:
  osmosisd tx ibc-transfer [flags]
  osmosisd tx ibc-transfer [command]

Available Commands:
  transfer    Transfer a fungible token through IBC

Flags:
  -h, --help   help for ibc-transfer

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "osmosisd tx ibc-transfer [command] --help" for more information about a command.
</cli>

<cli>osmosisd tx ibc-transfer transfer --help

Transfer a fungible token through IBC. Timeouts can be specified
as absolute or relative using the "absolute-timeouts" flag. Timeout height can be set by passing in the height string
in the form {revision}-{height} using the "packet-timeout-height" flag. Relative timeout height is added to the block
height queried from the latest consensus state corresponding to the counterparty channel. Relative timeout timestamp 
is added to the greater value of the local clock time and the block timestamp queried from the latest consensus state 
corresponding to the counterparty channel. Any timeout set to 0 is disabled.

Usage:
  osmosisd tx ibc-transfer transfer [src-port] [src-channel] [receiver] [amount] [flags]

Examples:
osmosisd tx ibc-transfer transfer [src-port] [src-channel] [receiver] [amount]

Flags:
      --absolute-timeouts               Timeout flags are used as absolute timeouts.
  -a, --account-number uint             The account number of the signing account (offline mode only)
      --aux                             Generate aux signer data instead of sending a tx
  -b, --broadcast-mode string           Transaction broadcasting mode (sync|async) (default "sync")
      --chain-id string                 The network chain ID
      --dry-run                         ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it (when enabled, the local Keybase is not accessible)
      --fee-granter string              Fee granter grants fees for the transaction
      --fee-payer string                Fee payer pays fees for the transaction instead of deducting from the signer
      --fees string                     Fees to pay along with transaction; eg: 10uatom
      --from string                     Name or address of private key with which to sign
      --gas string                      gas limit to set per-transaction; set to "auto" to calculate sufficient gas automatically. Note: "auto" option doesn't always report accurate results. Set a valid coin value to adjust the result. Can be used instead of "fees". (default 200000)
      --gas-adjustment float            adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored  (default 1)
      --gas-prices string               Gas prices in decimal format to determine the transaction fee (e.g. 0.1uatom)
      --generate-only                   Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase only accessed when providing a key name)
  -h, --help                            help for transfer
      --keyring-backend string          Select keyring's backend (os|file|kwallet|pass|test|memory) (default "os")
      --keyring-dir string              The client Keyring directory; if omitted, the default 'home' directory will be used
      --ledger                          Use a connected Ledger device
      --memo string                     Memo to be sent along with the packet.
      --node string                     <host>:<port> to tendermint rpc interface for this chain (default "tcp://localhost:26657")
      --note string                     Note to add a description to the transaction (previously --memo)
      --offline                         Offline mode (does not allow any online functionality)
  -o, --output string                   Output format (text|json) (default "json")
      --packet-timeout-height string    Packet timeout block height. The timeout is disabled when set to 0-0. (default "0-1000")
      --packet-timeout-timestamp uint   Packet timeout timestamp in nanoseconds from now. Default is 10 minutes. The timeout is disabled when set to 0. (default 600000000000)
  -s, --sequence uint                   The sequence number of the signing account (offline mode only)
      --sign-mode string                Choose sign mode (direct|amino-json|direct-aux), this is an advanced feature
      --timeout-height uint             Set a block timeout height to prevent the tx from being committed past a certain height
      --tip string                      Tip is the amount that is going to be transferred to the fee payer on the target chain. This flag is only valid when used with --aux, and is ignored if the target chain didn't enable the TipDecorator
  -y, --yes                             Skip tx broadcasting prompt confirmation

Global Flags:
      --home string         directory for config and data (default "/home/ubuntu/.osmosisd")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc --help

Querying commands for the IBC module

Usage:
  gaiad query ibc [flags]
  gaiad query ibc [command]

Available Commands:
  channel     IBC channel query subcommands
  client      IBC client query subcommands
  connection  IBC connection query subcommands

Flags:
  -h, --help   help for ibc

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad query ibc [command] --help" for more information about a command.
</cli>

<cli>gaiad query ibc channel --help

IBC channel query subcommands

Usage:
  gaiad query ibc channel [flags]
  gaiad query ibc channel [command]

Available Commands:
  channels              Query all channels
  client-state          Query the client state associated with a channel
  connections           Query all channels associated with a connection
  end                   Query a channel end
  next-sequence-receive Query a next receive sequence
  packet-ack            Query a packet acknowledgement
  packet-commitment     Query a packet commitment
  packet-commitments    Query all packet commitments associated with a channel
  packet-receipt        Query a packet receipt
  unreceived-acks       Query all the unreceived acks associated with a channel
  unreceived-packets    Query all the unreceived packets associated with a channel

Flags:
  -h, --help   help for channel

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad query ibc channel [command] --help" for more information about a command.
</cli>

<cli>gaiad query ibc channel channels --help

Query all channels from a chain

Usage:
  gaiad query ibc channel channels [flags]

Examples:
gaiad query ibc channel channels

Flags:
      --count-total       count total number of records in channels to query for
      --height int        Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help              help for channels
      --limit uint        pagination limit of channels to query for (default 100)
      --node string       <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint       pagination offset of channels to query for
  -o, --output string     Output format (text|json) (default "text")
      --page uint         pagination page of channels to query for. This sets offset to a multiple of limit (default 1)
      --page-key string   pagination page-key of channels to query for
      --reverse           results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc channel client-state --help

Query the client state associated with a channel, by providing its port and channel identifiers.

Usage:
  gaiad query ibc channel client-state [port-id] [channel-id] [flags]

Examples:
gaiad query ibc channel client-state [port-id] [channel-id]

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for client-state
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc channel connections --help

Query all channels associated with a connection

Usage:
  gaiad query ibc channel connections [connection-id] [flags]

Examples:
gaiad query ibc channel connections [connection-id]

Flags:
      --count-total       count total number of records in channels associated with a connection to query for
      --height int        Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help              help for connections
      --limit uint        pagination limit of channels associated with a connection to query for (default 100)
      --node string       <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint       pagination offset of channels associated with a connection to query for
  -o, --output string     Output format (text|json) (default "text")
      --page uint         pagination page of channels associated with a connection to query for. This sets offset to a multiple of limit (default 1)
      --page-key string   pagination page-key of channels associated with a connection to query for
      --reverse           results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc channel end --help

Query an IBC channel end from a port and channel identifiers

Usage:
  gaiad query ibc channel end [port-id] [channel-id] [flags]

Examples:
gaiad query ibc channel end [port-id] [channel-id]

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for end
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")
      --prove           show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc channel next-sequence-receive --help

Query the next receive sequence for a given channel

Usage:
  gaiad query ibc channel next-sequence-receive [port-id] [channel-id] [flags]

Examples:
gaiad query ibc channel next-sequence-receive [port-id] [channel-id]

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for next-sequence-receive
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")
      --prove           show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc channel packet-ack --help

Query a packet acknowledgement

Usage:
  gaiad query ibc channel packet-ack [port-id] [channel-id] [sequence] [flags]

Examples:
gaiad query ibc channel packet-ack [port-id] [channel-id] [sequence]

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for packet-ack
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")
      --prove           show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc channel packet-commitment --help

Query a packet commitment

Usage:
  gaiad query ibc channel packet-commitment [port-id] [channel-id] [sequence] [flags]

Examples:
gaiad query ibc channel packet-commitment [port-id] [channel-id] [sequence]

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for packet-commitment
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")
      --prove           show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc channel packet-commitments --help

Query all packet commitments associated with a channel

Usage:
  gaiad query ibc channel packet-commitments [port-id] [channel-id] [flags]

Examples:
gaiad query ibc channel packet-commitments [port-id] [channel-id]

Flags:
      --count-total       count total number of records in packet commitments associated with a channel to query for
      --height int        Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help              help for packet-commitments
      --limit uint        pagination limit of packet commitments associated with a channel to query for (default 100)
      --node string       <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint       pagination offset of packet commitments associated with a channel to query for
  -o, --output string     Output format (text|json) (default "text")
      --page uint         pagination page of packet commitments associated with a channel to query for. This sets offset to a multiple of limit (default 1)
      --page-key string   pagination page-key of packet commitments associated with a channel to query for
      --reverse           results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc channel packet-receipt --help

Query a packet receipt

Usage:
  gaiad query ibc channel packet-receipt [port-id] [channel-id] [sequence] [flags]

Examples:
gaiad query ibc channel packet-receipt [port-id] [channel-id] [sequence]

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for packet-receipt
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")
      --prove           show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc channel unreceived-acks --help

Given a list of acknowledgement sequences from counterparty, determine if an ack on the counterparty chain has been received on the executing chain.

The return value represents:
- Unreceived packet acknowledgement: packet commitment exists on original sending (executing) chain and ack exists on receiving chain.

Usage:
  gaiad query ibc channel unreceived-acks [port-id] [channel-id] [flags]

Examples:
gaiad query ibc channel unreceived-acks [port-id] [channel-id] --sequences=1,2,3

Flags:
      --height int             Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help                   help for unreceived-acks
      --node string            <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string          Output format (text|json) (default "text")
      --sequences int64Slice   comma separated list of packet sequence numbers (default [])

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc channel unreceived-packets --help

Determine if a packet, given a list of packet commitment sequences, is unreceived.

The return value represents:
- Unreceived packet commitments: no acknowledgement exists on receiving chain for the given packet commitment sequence on sending chain.

Usage:
  gaiad query ibc channel unreceived-packets [port-id] [channel-id] [flags]

Examples:
gaiad query ibc channel unreceived-packets [port-id] [channel-id] --sequences=1,2,3

Flags:
      --height int             Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help                   help for unreceived-packets
      --node string            <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string          Output format (text|json) (default "text")
      --sequences int64Slice   comma separated list of packet sequence numbers (default [])

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc client --help

IBC client query subcommands

Usage:
  gaiad query ibc client [flags]
  gaiad query ibc client [command]

Available Commands:
  consensus-state         Query the consensus state of a client at a given height
  consensus-state-heights Query the heights of all consensus states of a client.
  consensus-states        Query all the consensus states of a client.
  header                  Query the latest header of the running chain
  params                  Query the current ibc client parameters
  self-consensus-state    Query the self consensus state for this chain
  state                   Query a client state
  states                  Query all available light clients
  status                  Query client status

Flags:
  -h, --help   help for client

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad query ibc client [command] --help" for more information about a command.
</cli>

<cli>gaiad query ibc client consensus-state --help

Query the consensus state for a particular light client at a given height.
If the '--latest' flag is included, the query returns the latest consensus state, overriding the height argument.

Usage:
  gaiad query ibc client consensus-state [client-id] [height] [flags]

Examples:
gaiad query ibc client  consensus-state [client-id] [height]

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for consensus-state
      --latest-height   return latest stored consensus state
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")
      --prove           show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc client consensus-state-heights --help

Query the heights of all consensus states associated with the provided client ID.

Usage:
  gaiad query ibc client consensus-state-heights [client-id] [flags]

Examples:
gaiad query ibc client consensus-state-heights [client-id]

Flags:
      --count-total       count total number of records in consensus state heights to query for
      --height int        Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help              help for consensus-state-heights
      --limit uint        pagination limit of consensus state heights to query for (default 100)
      --node string       <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint       pagination offset of consensus state heights to query for
  -o, --output string     Output format (text|json) (default "text")
      --page uint         pagination page of consensus state heights to query for. This sets offset to a multiple of limit (default 1)
      --page-key string   pagination page-key of consensus state heights to query for
      --reverse           results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc client consensus-states --help

Query all the consensus states from a given client state.

Usage:
  gaiad query ibc client consensus-states [client-id] [flags]

Examples:
gaiad query ibc client consensus-states [client-id]

Flags:
      --count-total       count total number of records in consensus states to query for
      --height int        Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help              help for consensus-states
      --limit uint        pagination limit of consensus states to query for (default 100)
      --node string       <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint       pagination offset of consensus states to query for
  -o, --output string     Output format (text|json) (default "text")
      --page uint         pagination page of consensus states to query for. This sets offset to a multiple of limit (default 1)
      --page-key string   pagination page-key of consensus states to query for
      --reverse           results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc client header --help

Query the latest Tendermint header of the running chain

Usage:
  gaiad query ibc client header [flags]

Examples:
gaiad query ibc client  header

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for header
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc client params --help

Query the current ibc client parameters

Usage:
  gaiad query ibc client params [flags]

Examples:
gaiad query ibc client params

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for params
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc client self-consensus-state --help

Query the self consensus state for this chain. This result may be used for verifying IBC clients representing this chain which are hosted on counterparty chains.

Usage:
  gaiad query ibc client self-consensus-state [flags]

Examples:
gaiad query ibc client self-consensus-state

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for self-consensus-state
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc client state --help

Query stored client state

Usage:
  gaiad query ibc client state [client-id] [flags]

Examples:
gaiad query ibc client state [client-id]

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for state
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")
      --prove           show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc client states --help

Query all available light clients

Usage:
  gaiad query ibc client states [flags]

Examples:
gaiad query ibc client states

Flags:
      --count-total       count total number of records in client states to query for
      --height int        Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help              help for states
      --limit uint        pagination limit of client states to query for (default 100)
      --node string       <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint       pagination offset of client states to query for
  -o, --output string     Output format (text|json) (default "text")
      --page uint         pagination page of client states to query for. This sets offset to a multiple of limit (default 1)
      --page-key string   pagination page-key of client states to query for
      --reverse           results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc client status --help

Query client activity status. Any client without an 'Active' status is considered inactive

Usage:
  gaiad query ibc client status [client-id] [flags]

Examples:
gaiad query ibc client status [client-id]

Flags:
  -h, --help   help for status

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc connection --help

IBC connection query subcommands

Usage:
  gaiad query ibc connection [command]

Available Commands:
  connections Query all connections
  end         Query stored connection end
  path        Query stored client connection paths

Flags:
  -h, --help   help for connection

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad query ibc connection [command] --help" for more information about a command.
</cli>

<cli>gaiad query ibc connection connections --help

Query all connections ends from a chain

Usage:
  gaiad query ibc connection connections [flags]

Examples:
gaiad query ibc connection connections

Flags:
      --count-total       count total number of records in connection ends to query for
      --height int        Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help              help for connections
      --limit uint        pagination limit of connection ends to query for (default 100)
      --node string       <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint       pagination offset of connection ends to query for
  -o, --output string     Output format (text|json) (default "text")
      --page uint         pagination page of connection ends to query for. This sets offset to a multiple of limit (default 1)
      --page-key string   pagination page-key of connection ends to query for
      --reverse           results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc connection end --help

Query stored connection end

Usage:
  gaiad query ibc connection end [connection-id] [flags]

Examples:
gaiad query ibc connection end [connection-id]

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for end
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")
      --prove           show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc connection path --help

Query stored client connection paths

Usage:
  gaiad query ibc connection path [client-id] [flags]

Examples:
gaiad query  ibc connection path [client-id]

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for path
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")
      --prove           show proofs for the query results (default true)

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc-router --help

Usage:
  gaiad query ibc-router [command]

Available Commands:
  params      Query the current ibc-router parameters

Flags:
  -h, --help   help for ibc-router

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad query ibc-router [command] --help" for more information about a command.
</cli>

<cli>gaiad query ibc-router params --help

Query the current ibc-router parameters

Usage:
  gaiad query ibc-router params [flags]

Examples:
gaiad query ibc-router params

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for params
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc-transfer --help

IBC fungible token transfer query subcommands

Usage:
  gaiad query ibc-transfer [command]

Available Commands:
  denom-hash     Query the denom hash info from a given denom trace
  denom-trace    Query the denom trace info from a given trace hash or ibc denom
  denom-traces   Query the trace info for all token denominations
  escrow-address Get the escrow address for a channel
  params         Query the current ibc-transfer parameters

Flags:
  -h, --help   help for ibc-transfer

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad query ibc-transfer [command] --help" for more information about a command.
</cli>

<cli>gaiad query ibc-transfer denom-hash --help

Query the denom hash info from a given denom trace

Usage:
  gaiad query ibc-transfer denom-hash [trace] [flags]

Examples:
gaiad query ibc-transfer denom-hash transfer/channel-0/uatom

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for denom-hash
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc-transfer denom-trace --help

Query the denom trace info from a given trace hash or ibc denom

Usage:
  gaiad query ibc-transfer denom-trace [hash/denom] [flags]

Examples:
gaiad query ibc-transfer denom-trace 27A6394C3F9FF9C9DCF5DFFADF9BB5FE9A37C7E92B006199894CF1824DF9AC7C

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for denom-trace
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc-transfer denom-traces --help

Query the trace info for all token denominations

Usage:
  gaiad query ibc-transfer denom-traces [flags]

Examples:
gaiad query ibc-transfer denom-traces

Flags:
      --count-total       count total number of records in denominations trace to query for
      --height int        Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help              help for denom-traces
      --limit uint        pagination limit of denominations trace to query for (default 100)
      --node string       <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
      --offset uint       pagination offset of denominations trace to query for
  -o, --output string     Output format (text|json) (default "text")
      --page uint         pagination page of denominations trace to query for. This sets offset to a multiple of limit (default 1)
      --page-key string   pagination page-key of denominations trace to query for
      --reverse           results are sorted in descending order

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc-transfer escrow-address --help

Get the escrow address for a channel

Usage:
  gaiad query ibc-transfer escrow-address [flags]

Examples:
gaiad query ibc-transfer escrow-address [port] [channel-id]

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for escrow-address
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query ibc-transfer params --help

Query the current ibc-transfer parameters

Usage:
  gaiad query ibc-transfer params [flags]

Examples:
gaiad query ibc-transfer params

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for params
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query interchain-accounts --help

interchain-accounts subcommands

Usage:
  gaiad query interchain-accounts [command]

Aliases:
  interchain-accounts, ica

Available Commands:
  controller  interchain-accounts controller subcommands
  host        interchain-accounts host subcommands

Flags:
  -h, --help   help for interchain-accounts

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad query interchain-accounts [command] --help" for more information about a command.
</cli>

<cli>gaiad query interchain-accounts controller --help

interchain-accounts controller subcommands

Usage:
  gaiad query interchain-accounts controller [command]

Available Commands:
  interchain-account Query the interchain account address for a given owner on a particular connection
  params             Query the current interchain-accounts controller submodule parameters

Flags:
  -h, --help   help for controller

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad query interchain-accounts controller [command] --help" for more information about a command.
</cli>

<cli>gaiad query interchain-accounts controller interchain-account --help

Query the controller submodule for the interchain account address for a given owner on a particular connection

Usage:
  gaiad query interchain-accounts controller interchain-account [owner] [connection-id] [flags]

Examples:
gaiad query interchain-accounts controller interchain-account cosmos1layxcsmyye0dc0har9sdfzwckaz8sjwlfsj8zs connection-0

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for interchain-account
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query interchain-accounts controller params --help

Query the current interchain-accounts controller submodule parameters

Usage:
  gaiad query interchain-accounts controller params [flags]

Examples:
gaiad query interchain-accounts controller params

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for params
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query interchain-accounts host --help

interchain-accounts host subcommands

Usage:
  gaiad query interchain-accounts host [command]

Available Commands:
  packet-events Query the interchain-accounts host submodule packet events
  params        Query the current interchain-accounts host submodule parameters

Flags:
  -h, --help   help for host

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad query interchain-accounts host [command] --help" for more information about a command.
</cli>

<cli>gaiad query interchain-accounts host packet-events --help

Query the interchain-accounts host submodule packet events for a particular channel and sequence

Usage:
  gaiad query interchain-accounts host packet-events [channel-id] [sequence] [flags]

Examples:
gaiad query interchain-accounts host packet-events channel-0 100

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for packet-events
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad query interchain-accounts host params --help

Query the current interchain-accounts host submodule parameters

Usage:
  gaiad query interchain-accounts host params [flags]

Examples:
gaiad query interchain-accounts host params

Flags:
      --height int      Use a specific height to query state at (this can error if the node is pruning state)
  -h, --help            help for params
      --node string     <host>:<port> to Tendermint RPC interface for this chain (default "tcp://localhost:26657")
  -o, --output string   Output format (text|json) (default "text")

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>


<cli>gaiad tx ibc --help

IBC transaction subcommands

Usage:
  gaiad tx ibc [flags]
  gaiad tx ibc [command]

Available Commands:
  channel     IBC channel transaction subcommands
  client      IBC client transaction subcommands

Flags:
  -h, --help   help for ibc

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad tx ibc [command] --help" for more information about a command.
</cli>

<cli>gaiad tx ibc channel --help

IBC channel transaction subcommands

Usage:
  gaiad tx ibc channel [flags]

Flags:
  -h, --help   help for channel

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad tx ibc client --help

IBC client transaction subcommands

Usage:
  gaiad tx ibc client [flags]
  gaiad tx ibc client [command]

Available Commands:
  create       create new IBC client
  misbehaviour submit a client misbehaviour
  update       update existing client with a header
  upgrade      upgrade an IBC client

Flags:
  -h, --help   help for client

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad tx ibc client [command] --help" for more information about a command.
</cli>

<cli>gaiad tx ibc client create --help

create a new IBC client with the specified client state and consensus state
	- ClientState JSON example: {"@type":"/ibc.lightclients.solomachine.v1.ClientState","sequence":"1","frozen_sequence":"0","consensus_state":{"public_key":{"@type":"/cosmos.crypto.secp256k1.PubKey","key":"AtK50+5pJOoaa04qqAqrnyAqsYrwrR/INnA6UPIaYZlp"},"diversifier":"testing","timestamp":"10"},"allow_update_after_proposal":false}
	- ConsensusState JSON example: {"@type":"/ibc.lightclients.solomachine.v1.ConsensusState","public_key":{"@type":"/cosmos.crypto.secp256k1.PubKey","key":"AtK50+5pJOoaa04qqAqrnyAqsYrwrR/INnA6UPIaYZlp"},"diversifier":"testing","timestamp":"10"}

Usage:
  gaiad tx ibc client create [path/to/client_state.json] [path/to/consensus_state.json] [flags]

Examples:
gaiad tx ibc client create [path/to/client_state.json] [path/to/consensus_state.json] --from node0 --home ../node0/<app>cli --chain-id $CID

Flags:
  -a, --account-number uint      The account number of the signing account (offline mode only)
  -b, --broadcast-mode string    Transaction broadcasting mode (sync|async|block) (default "sync")
      --dry-run                  ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it (when enabled, the local Keybase is not accessible)
      --fee-account string       Fee account pays fees for the transaction instead of deducting from the signer
      --fees string              Fees to pay along with transaction; eg: 10uatom
      --from string              Name or address of private key with which to sign
      --gas string               gas limit to set per-transaction; set to "auto" to calculate sufficient gas automatically (default 200000)
      --gas-adjustment float     adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored  (default 1)
      --gas-prices string        Gas prices in decimal format to determine the transaction fee (e.g. 0.1uatom)
      --generate-only            Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase is not accessible)
  -h, --help                     help for create
      --keyring-backend string   Select keyring's backend (os|file|kwallet|pass|test|memory) (default "os")
      --keyring-dir string       The client Keyring directory; if omitted, the default 'home' directory will be used
      --ledger                   Use a connected Ledger device
      --node string              <host>:<port> to tendermint rpc interface for this chain (default "tcp://localhost:26657")
      --note string              Note to add a description to the transaction (previously --memo)
      --offline                  Offline mode (does not allow any online functionality
  -o, --output string            Output format (text|json) (default "json")
  -s, --sequence uint            The sequence number of the signing account (offline mode only)
      --sign-mode string         Choose sign mode (direct|amino-json), this is an advanced feature
      --timeout-height uint      Set a block timeout height to prevent the tx from being committed past a certain height
  -y, --yes                      Skip tx broadcasting prompt confirmation

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad tx ibc client misbehaviour --help

submit a client misbehaviour to prevent future updates

Usage:
  gaiad tx ibc client misbehaviour [path/to/misbehaviour.json] [flags]

Examples:
gaiad tx ibc client misbehaviour [path/to/misbehaviour.json] --from node0 --home ../node0/<app>cli --chain-id $CID

Flags:
  -h, --help   help for misbehaviour

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad tx ibc client update --help

update existing client with a header

Usage:
  gaiad tx ibc client update [client-id] [path/to/header.json] [flags]

Examples:
gaiad tx ibc client update [client-id] [path/to/header.json] --from node0 --home ../node0/<app>cli --chain-id $CID

Flags:
  -h, --help   help for update

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad tx ibc client upgrade --help

upgrade the IBC client associated with the provided client identifier while providing proof committed by the counterparty chain to the new client and consensus states
	- ClientState JSON example: {"@type":"/ibc.lightclients.solomachine.v1.ClientState","sequence":"1","frozen_sequence":"0","consensus_state":{"public_key":{"@type":"/cosmos.crypto.secp256k1.PubKey","key":"AtK50+5pJOoaa04qqAqrnyAqsYrwrR/INnA6UPIaYZlp"},"diversifier":"testing","timestamp":"10"},"allow_update_after_proposal":false}
	- ConsensusState JSON example: {"@type":"/ibc.lightclients.solomachine.v1.ConsensusState","public_key":{"@type":"/cosmos.crypto.secp256k1.PubKey","key":"AtK50+5pJOoaa04qqAqrnyAqsYrwrR/INnA6UPIaYZlp"},"diversifier":"testing","timestamp":"10"}

Usage:
  gaiad tx ibc client upgrade [client-identifier] [path/to/client_state.json] [path/to/consensus_state.json] [upgrade-client-proof] [upgrade-consensus-state-proof] [flags]

Examples:
gaiad tx ibc client upgrade [client-identifier] [path/to/client_state.json] [path/to/consensus_state.json] [client-state-proof] [consensus-state-proof] --from node0 --home ../node0/<app>cli --chain-id $CID

Flags:
  -a, --account-number uint      The account number of the signing account (offline mode only)
  -b, --broadcast-mode string    Transaction broadcasting mode (sync|async|block) (default "sync")
      --dry-run                  ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it (when enabled, the local Keybase is not accessible)
      --fee-account string       Fee account pays fees for the transaction instead of deducting from the signer
      --fees string              Fees to pay along with transaction; eg: 10uatom
      --from string              Name or address of private key with which to sign
      --gas string               gas limit to set per-transaction; set to "auto" to calculate sufficient gas automatically (default 200000)
      --gas-adjustment float     adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored  (default 1)
      --gas-prices string        Gas prices in decimal format to determine the transaction fee (e.g. 0.1uatom)
      --generate-only            Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase is not accessible)
  -h, --help                     help for upgrade
      --keyring-backend string   Select keyring's backend (os|file|kwallet|pass|test|memory) (default "os")
      --keyring-dir string       The client Keyring directory; if omitted, the default 'home' directory will be used
      --ledger                   Use a connected Ledger device
      --node string              <host>:<port> to tendermint rpc interface for this chain (default "tcp://localhost:26657")
      --note string              Note to add a description to the transaction (previously --memo)
      --offline                  Offline mode (does not allow any online functionality
  -o, --output string            Output format (text|json) (default "json")
  -s, --sequence uint            The sequence number of the signing account (offline mode only)
      --sign-mode string         Choose sign mode (direct|amino-json), this is an advanced feature
      --timeout-height uint      Set a block timeout height to prevent the tx from being committed past a certain height
  -y, --yes                      Skip tx broadcasting prompt confirmation

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>

<cli>gaiad tx ibc-transfer --help

IBC fungible token transfer transaction subcommands

Usage:
  gaiad tx ibc-transfer [flags]
  gaiad tx ibc-transfer [command]

Available Commands:
  transfer    Transfer a fungible token through IBC

Flags:
  -h, --help   help for ibc-transfer

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors

Use "gaiad tx ibc-transfer [command] --help" for more information about a command.
</cli>

<cli>gaiad tx ibc-transfer transfer --help

Transfer a fungible token through IBC. Timeouts can be specified
as absolute or relative using the "absolute-timeouts" flag. Timeout height can be set by passing in the height string
in the form {revision}-{height} using the "packet-timeout-height" flag. Relative timeout height is added to the block
height queried from the latest consensus state corresponding to the counterparty channel. Relative timeout timestamp 
is added to the greater value of the local clock time and the block timestamp queried from the latest consensus state 
corresponding to the counterparty channel. Any timeout set to 0 is disabled.

Usage:
  gaiad tx ibc-transfer transfer [src-port] [src-channel] [receiver] [amount] [flags]

Examples:
gaiad tx ibc-transfer transfer [src-port] [src-channel] [receiver] [amount]

Flags:
      --absolute-timeouts               Timeout flags are used as absolute timeouts.
  -a, --account-number uint             The account number of the signing account (offline mode only)
  -b, --broadcast-mode string           Transaction broadcasting mode (sync|async|block) (default "sync")
      --dry-run                         ignore the --gas flag and perform a simulation of a transaction, but don't broadcast it (when enabled, the local Keybase is not accessible)
      --fee-account string              Fee account pays fees for the transaction instead of deducting from the signer
      --fees string                     Fees to pay along with transaction; eg: 10uatom
      --from string                     Name or address of private key with which to sign
      --gas string                      gas limit to set per-transaction; set to "auto" to calculate sufficient gas automatically (default 200000)
      --gas-adjustment float            adjustment factor to be multiplied against the estimate returned by the tx simulation; if the gas limit is set manually this flag is ignored  (default 1)
      --gas-prices string               Gas prices in decimal format to determine the transaction fee (e.g. 0.1uatom)
      --generate-only                   Build an unsigned transaction and write it to STDOUT (when enabled, the local Keybase is not accessible)
  -h, --help                            help for transfer
      --keyring-backend string          Select keyring's backend (os|file|kwallet|pass|test|memory) (default "os")
      --keyring-dir string              The client Keyring directory; if omitted, the default 'home' directory will be used
      --ledger                          Use a connected Ledger device
      --memo string                     Memo to be sent along with the packet.
      --node string                     <host>:<port> to tendermint rpc interface for this chain (default "tcp://localhost:26657")
      --note string                     Note to add a description to the transaction (previously --memo)
      --offline                         Offline mode (does not allow any online functionality
  -o, --output string                   Output format (text|json) (default "json")
      --packet-timeout-height string    Packet timeout block height. The timeout is disabled when set to 0-0. (default "0-1000")
      --packet-timeout-timestamp uint   Packet timeout timestamp in nanoseconds from now. Default is 10 minutes. The timeout is disabled when set to 0. (default 600000000000)
  -s, --sequence uint                   The sequence number of the signing account (offline mode only)
      --sign-mode string                Choose sign mode (direct|amino-json), this is an advanced feature
      --timeout-height uint             Set a block timeout height to prevent the tx from being committed past a certain height
  -y, --yes                             Skip tx broadcasting prompt confirmation

Global Flags:
      --chain-id string     The network chain ID
      --home string         directory for config and data (default "/home/ubuntu/.gaia")
      --log_format string   The logging format (json|plain) (default "plain")
      --log_level string    The logging level (trace|debug|info|warn|error|fatal|panic) (default "info")
      --trace               print out full stack trace on errors
</cli>


