{
  "431": "pub mod transactions;\npub mod validation;\n",
  "432": "# test_utils\n\nContains helper functionality and fixtures for use in tests. This crate must be wasm-buildable by default as it may be used from within our test wasms.",
  "436": "mod generated;\n\npub use generated::types::Tx;\n",
  "437": "pub mod types;\n",
  "438": [
    "SourceCode",
    "Validity",
    "Predicate",
    "Eval",
    "CodeHash",
    "Input",
    "Transaction",
    "Borsh",
    "Serde"
  ],
  "456": "use color_eyre::eyre::Result;\nuse namada_apps::cli::api::{CliApi, CliIo};\nuse namada_apps::facade::tendermint_rpc::HttpClient;\nuse namada_apps::{cli, logging};\nuse tracing_subscriber::filter::LevelFilter;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // init error reporting\n    color_eyre::install()?;\n\n    // init logging\n    let _log_guard = logging::init_from_env_or(LevelFilter::INFO)?;\n\n    // run the CLI\n    CliApi::handle_client_command::<HttpClient, _>(\n        None,\n        cli::namada_client_cli()?,\n        CliIo,\n    )\n    .await\n}\n",
  "457": "mod cli;\n\nuse color_eyre::eyre::Result;\nuse namada_apps::logging;\nuse tracing_subscriber::filter::LevelFilter;\n\nfn main() -> Result<()> {\n    // init error reporting\n    color_eyre::install()?;\n\n    // init logging\n    let _log_guard = logging::init_from_env_or(LevelFilter::INFO)?;\n\n    // run the CLI\n    cli::main()\n}\n",
  "459": "use color_eyre::eyre::Result;\nuse namada::tendermint_rpc::HttpClient;\nuse namada_apps::cli::api::{CliApi, CliIo};\nuse namada_apps::{cli, logging};\nuse tracing_subscriber::filter::LevelFilter;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n    // init error reporting\n    color_eyre::install()?;\n\n    // init logging\n    logging::init_from_env_or(LevelFilter::INFO)?;\n\n    let cmd = cli::namada_relayer_cli()?;\n    // run the CLI\n    CliApi::handle_relayer_command::<HttpClient>(None, cmd, CliIo).await\n}\n",
  "460": "mod cli;\n\nuse color_eyre::eyre::Result;\nuse namada_apps::logging;\nuse tracing_subscriber::filter::LevelFilter;\n\nfn main() -> Result<()> {\n    color_eyre::install()?;\n\n    // init logging\n    let _log_guard = logging::init_from_env_or(LevelFilter::INFO)?;\n\n    // run the CLI\n    cli::main()\n}\n",
  "462": "use color_eyre::eyre::Result;\nuse namada_apps::cli;\nuse namada_apps::cli::api::{CliApi, CliIo};\n\n#[tokio::main]\npub async fn main() -> Result<()> {\n    color_eyre::install()?;\n    let (cmd, ctx) = cli::namada_wallet_cli()?;\n    // run the CLI\n    CliApi::handle_wallet_command(cmd, ctx, &CliIo).await\n}\n",
  "463": "# Namada CLI wallet\n\n## Features\n\n- Manage ed2551 keys\n  - Generate and store new keypairs\n  - Lookup secret keys from a public key, public key hash or an alias for signing txs\n  - List all known keys\n- Managing addresses\n  - Derive and store implicit addresses from keys\n  - Save established addresses created from transactions\n  - Lookup addresses from aliases\n  - List all known addresses\n  - Add new addresses to the wallet\n- Persist data from/into a file\n",
  "468": "pub mod ledger;\n",
  "486": "pub mod masp;\npub mod rpc;\npub mod tx;\npub mod utils;\n",
  "497": "use borsh::BorshDeserialize;\nuse namada::core::storage::Key;\nuse namada::state::{self, StorageRead};\n\npub(super) fn force_read<S, T>(\n    storage: &S,\n    key: &Key,\n) -> state::StorageResult<T>\nwhere\n    S: StorageRead,\n    T: BorshDeserialize,\n{\n    storage\n        .read::<T>(key)\n        .transpose()\n        .expect(\"Storage key must be present.\")\n}\n",
  "505": "pub mod client;\npub mod node;\npub mod utils;\n",
  "512": "use super::super::{AllocFailure, BlockAllocator};\nuse super::{BuildingProtocolTxBatch, TryAlloc};\n\nimpl TryAlloc for BlockAllocator<BuildingProtocolTxBatch> {\n    type Resources<'tx> = &'tx [u8];\n\n    #[inline]\n    fn try_alloc(\n        &mut self,\n        tx: Self::Resources<'_>,\n    ) -> Result<(), AllocFailure> {\n        self.protocol_txs.try_dump(tx)\n    }\n}\n",
  "516": "pub mod abcipp_shim;\npub mod abcipp_shim_types;\n",
  "525": "pub mod ledger;\n",
  "543": "#[cfg(not(feature = \"blocking\"))]\npub mod asynchronous;\n#[cfg(feature = \"blocking\")]\npub mod blocking;\n",
  "551": "use super::*;\n\n/// Check if the given address is a pgf steward.\npub async fn is_steward(\n    tendermint_addr: &str,\n    address: &Address,\n) -> Result<bool, Error> {\n    let client = HttpClient::new(\n        TendermintAddress::from_str(tendermint_addr)\n            .map_err(|e| Error::Other(e.to_string()))?,\n    )\n    .map_err(|e| Error::Other(e.to_string()))?;\n    Ok(rpc::is_steward(&client, address).await)\n}\n",
  "552": "#[cfg(not(feature = \"blocking\"))]\npub mod asynchronous;\n#[cfg(feature = \"blocking\")]\npub mod blocking;\n",
  "558": "use super::*;\n\n/// Check if the given address is a pgf steward.\npub fn is_steward(\n    tendermint_addr: &str,\n    address: &Address,\n) -> Result<bool, Error> {\n    let client = HttpClient::new(\n        TendermintAddress::from_str(tendermint_addr)\n            .map_err(|e| Error::Other(e.to_string()))?,\n    )\n    .map_err(|e| Error::Other(e.to_string()))?;\n    let rt = Runtime::new().unwrap();\n    Ok(rt.block_on(rpc::is_steward(&client, address)))\n}\n",
  "561": "//! A helper module for dealing with bytes\n\nuse std::fmt::Display;\n\n/// A helper to show bytes in hex\npub struct ByteBuf<'a>(pub &'a [u8]);\n\nimpl<'a> std::fmt::LowerHex for ByteBuf<'a> {\n    fn fmt(\n        &self,\n        f: &mut std::fmt::Formatter,\n    ) -> std::result::Result<(), std::fmt::Error> {\n        for byte in self.0 {\n            f.write_fmt(format_args!(\"{:02x}\", byte))?;\n        }\n        Ok(())\n    }\n}\n\nimpl<'a> Display for ByteBuf<'a> {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"{:x}\", self)\n    }\n}\n",
  "602": "# Encoding specifications generator\n\nThis bin crate is used to derive encoding specifications from pre-selected public types via their `BorshSchema` implementations. The `BorshSchema` provides recursive definitions of all the used types and these are also included in the generated specification.\n\nWhen executed, this crate will generate `documentation/dev/src/specs/encoding/generated-borsh-spec.md` (see `OUTPUT_PATH` in the source). This page is itself included in the `documentation/dev/src/specs/encoding.md` page.\n",
  "616": "//! Governance library code\n\nuse namada_core::address::{self, Address};\n\n/// governance CLI structures\npub mod cli;\n/// governance parameters\npub mod parameters;\npub mod pgf;\n/// governance storage\npub mod storage;\n/// Governance utility functions/structs\npub mod utils;\n\npub use storage::proposal::{InitProposalData, ProposalType, VoteProposalData};\npub use storage::vote::ProposalVote;\npub use storage::{init_proposal, is_proposal_accepted, vote_proposal};\n\n/// The governance internal address\npub const ADDRESS: Address = address::GOV;\n"
}